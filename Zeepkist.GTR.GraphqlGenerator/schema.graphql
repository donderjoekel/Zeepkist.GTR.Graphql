schema {
  query: Query
  mutation: Mutation
  subscription: Subscription
}

"The root query type which gives access points into the data universe."
type Query implements Node {
  "Exposes the root query type nested one level down. This is helpful for Relay 1\nwhich can only query top level fields if they are in a particular form."
  query: Query!
  "The root query type must be a `Node` to work well with Relay 1 mutations. This just resolves to `query`."
  nodeId: ID!
  "Fetches an object given its globally unique `ID`."
  node("The globally unique `ID`." nodeId: ID!): Node
  "Reads and enables pagination through a set of `Favourite`."
  favourites("Only read the first `n` values of the set." first: Int "Only read the last `n` values of the set." last: Int "Skip the first `n` values from our `after` cursor, an alternative to cursor\nbased pagination. May not be used with `last`." offset: Int "Read all values in the set before (above) this cursor." before: Cursor "Read all values in the set after (below) this cursor." after: Cursor "The method to use when ordering `Favourite`." orderBy: [FavouritesOrderBy!] = [ PRIMARY_KEY_ASC ] "A condition to be used in determining which values should be returned by the collection." condition: FavouriteCondition "A filter to be used in determining which values should be returned by the collection." filter: FavouriteFilter): FavouritesConnection
  "Reads and enables pagination through a set of `Level`."
  levels("Only read the first `n` values of the set." first: Int "Only read the last `n` values of the set." last: Int "Skip the first `n` values from our `after` cursor, an alternative to cursor\nbased pagination. May not be used with `last`." offset: Int "Read all values in the set before (above) this cursor." before: Cursor "Read all values in the set after (below) this cursor." after: Cursor "The method to use when ordering `Level`." orderBy: [LevelsOrderBy!] = [ PRIMARY_KEY_ASC ] "A condition to be used in determining which values should be returned by the collection." condition: LevelCondition "A filter to be used in determining which values should be returned by the collection." filter: LevelFilter): LevelsConnection
  "Reads and enables pagination through a set of `LevelItem`."
  levelItems("Only read the first `n` values of the set." first: Int "Only read the last `n` values of the set." last: Int "Skip the first `n` values from our `after` cursor, an alternative to cursor\nbased pagination. May not be used with `last`." offset: Int "Read all values in the set before (above) this cursor." before: Cursor "Read all values in the set after (below) this cursor." after: Cursor "The method to use when ordering `LevelItem`." orderBy: [LevelItemsOrderBy!] = [ PRIMARY_KEY_ASC ] "A condition to be used in determining which values should be returned by the collection." condition: LevelItemCondition "A filter to be used in determining which values should be returned by the collection." filter: LevelItemFilter): LevelItemsConnection
  "Reads and enables pagination through a set of `LevelMetadatum`."
  levelMetadata("Only read the first `n` values of the set." first: Int "Only read the last `n` values of the set." last: Int "Skip the first `n` values from our `after` cursor, an alternative to cursor\nbased pagination. May not be used with `last`." offset: Int "Read all values in the set before (above) this cursor." before: Cursor "Read all values in the set after (below) this cursor." after: Cursor "The method to use when ordering `LevelMetadatum`." orderBy: [LevelMetadataOrderBy!] = [ PRIMARY_KEY_ASC ] "A condition to be used in determining which values should be returned by the collection." condition: LevelMetadatumCondition "A filter to be used in determining which values should be returned by the collection." filter: LevelMetadatumFilter): LevelMetadataConnection
  "Reads and enables pagination through a set of `LevelPoint`."
  levelPoints("Only read the first `n` values of the set." first: Int "Only read the last `n` values of the set." last: Int "Skip the first `n` values from our `after` cursor, an alternative to cursor\nbased pagination. May not be used with `last`." offset: Int "Read all values in the set before (above) this cursor." before: Cursor "Read all values in the set after (below) this cursor." after: Cursor "The method to use when ordering `LevelPoint`." orderBy: [LevelPointsOrderBy!] = [ PRIMARY_KEY_ASC ] "A condition to be used in determining which values should be returned by the collection." condition: LevelPointCondition "A filter to be used in determining which values should be returned by the collection." filter: LevelPointFilter): LevelPointsConnection
  "Reads and enables pagination through a set of `LevelPointsHistory`."
  levelPointsHistories("Only read the first `n` values of the set." first: Int "Only read the last `n` values of the set." last: Int "Skip the first `n` values from our `after` cursor, an alternative to cursor\nbased pagination. May not be used with `last`." offset: Int "Read all values in the set before (above) this cursor." before: Cursor "Read all values in the set after (below) this cursor." after: Cursor "The method to use when ordering `LevelPointsHistory`." orderBy: [LevelPointsHistoriesOrderBy!] = [ PRIMARY_KEY_ASC ] "A condition to be used in determining which values should be returned by the collection." condition: LevelPointsHistoryCondition "A filter to be used in determining which values should be returned by the collection." filter: LevelPointsHistoryFilter): LevelPointsHistoriesConnection
  "Reads and enables pagination through a set of `LevelRequest`."
  levelRequests("Only read the first `n` values of the set." first: Int "Only read the last `n` values of the set." last: Int "Skip the first `n` values from our `after` cursor, an alternative to cursor\nbased pagination. May not be used with `last`." offset: Int "Read all values in the set before (above) this cursor." before: Cursor "Read all values in the set after (below) this cursor." after: Cursor "The method to use when ordering `LevelRequest`." orderBy: [LevelRequestsOrderBy!] = [ PRIMARY_KEY_ASC ] "A condition to be used in determining which values should be returned by the collection." condition: LevelRequestCondition "A filter to be used in determining which values should be returned by the collection." filter: LevelRequestFilter): LevelRequestsConnection
  "Reads and enables pagination through a set of `PersonalBestGlobal`."
  personalBestGlobals("Only read the first `n` values of the set." first: Int "Only read the last `n` values of the set." last: Int "Skip the first `n` values from our `after` cursor, an alternative to cursor\nbased pagination. May not be used with `last`." offset: Int "Read all values in the set before (above) this cursor." before: Cursor "Read all values in the set after (below) this cursor." after: Cursor "The method to use when ordering `PersonalBestGlobal`." orderBy: [PersonalBestGlobalsOrderBy!] = [ PRIMARY_KEY_ASC ] "A condition to be used in determining which values should be returned by the collection." condition: PersonalBestGlobalCondition "A filter to be used in determining which values should be returned by the collection." filter: PersonalBestGlobalFilter): PersonalBestGlobalsConnection
  "Reads and enables pagination through a set of `Record`."
  records("Only read the first `n` values of the set." first: Int "Only read the last `n` values of the set." last: Int "Skip the first `n` values from our `after` cursor, an alternative to cursor\nbased pagination. May not be used with `last`." offset: Int "Read all values in the set before (above) this cursor." before: Cursor "Read all values in the set after (below) this cursor." after: Cursor "The method to use when ordering `Record`." orderBy: [RecordsOrderBy!] = [ PRIMARY_KEY_ASC ] "A condition to be used in determining which values should be returned by the collection." condition: RecordCondition "A filter to be used in determining which values should be returned by the collection." filter: RecordFilter): RecordsConnection
  "Reads and enables pagination through a set of `RecordMedia`."
  recordMedias("Only read the first `n` values of the set." first: Int "Only read the last `n` values of the set." last: Int "Skip the first `n` values from our `after` cursor, an alternative to cursor\nbased pagination. May not be used with `last`." offset: Int "Read all values in the set before (above) this cursor." before: Cursor "Read all values in the set after (below) this cursor." after: Cursor "The method to use when ordering `RecordMedia`." orderBy: [RecordMediaOrderBy!] = [ PRIMARY_KEY_ASC ] "A condition to be used in determining which values should be returned by the collection." condition: RecordMediaCondition "A filter to be used in determining which values should be returned by the collection." filter: RecordMediaFilter): RecordMediaConnection
  "Reads and enables pagination through a set of `User`."
  users("Only read the first `n` values of the set." first: Int "Only read the last `n` values of the set." last: Int "Skip the first `n` values from our `after` cursor, an alternative to cursor\nbased pagination. May not be used with `last`." offset: Int "Read all values in the set before (above) this cursor." before: Cursor "Read all values in the set after (below) this cursor." after: Cursor "The method to use when ordering `User`." orderBy: [UsersOrderBy!] = [ PRIMARY_KEY_ASC ] "A condition to be used in determining which values should be returned by the collection." condition: UserCondition "A filter to be used in determining which values should be returned by the collection." filter: UserFilter): UsersConnection
  "Reads and enables pagination through a set of `UserPoint`."
  userPoints("Only read the first `n` values of the set." first: Int "Only read the last `n` values of the set." last: Int "Skip the first `n` values from our `after` cursor, an alternative to cursor\nbased pagination. May not be used with `last`." offset: Int "Read all values in the set before (above) this cursor." before: Cursor "Read all values in the set after (below) this cursor." after: Cursor "The method to use when ordering `UserPoint`." orderBy: [UserPointsOrderBy!] = [ PRIMARY_KEY_ASC ] "A condition to be used in determining which values should be returned by the collection." condition: UserPointCondition "A filter to be used in determining which values should be returned by the collection." filter: UserPointFilter): UserPointsConnection
  "Reads and enables pagination through a set of `UserPointsHistory`."
  userPointsHistories("Only read the first `n` values of the set." first: Int "Only read the last `n` values of the set." last: Int "Skip the first `n` values from our `after` cursor, an alternative to cursor\nbased pagination. May not be used with `last`." offset: Int "Read all values in the set before (above) this cursor." before: Cursor "Read all values in the set after (below) this cursor." after: Cursor "The method to use when ordering `UserPointsHistory`." orderBy: [UserPointsHistoriesOrderBy!] = [ PRIMARY_KEY_ASC ] "A condition to be used in determining which values should be returned by the collection." condition: UserPointsHistoryCondition "A filter to be used in determining which values should be returned by the collection." filter: UserPointsHistoryFilter): UserPointsHistoriesConnection
  "Reads and enables pagination through a set of `Version`."
  versions("Only read the first `n` values of the set." first: Int "Only read the last `n` values of the set." last: Int "Skip the first `n` values from our `after` cursor, an alternative to cursor\nbased pagination. May not be used with `last`." offset: Int "Read all values in the set before (above) this cursor." before: Cursor "Read all values in the set after (below) this cursor." after: Cursor "The method to use when ordering `Version`." orderBy: [VersionsOrderBy!] = [ PRIMARY_KEY_ASC ] "A condition to be used in determining which values should be returned by the collection." condition: VersionCondition "A filter to be used in determining which values should be returned by the collection." filter: VersionFilter): VersionsConnection
  "Reads and enables pagination through a set of `Vote`."
  votes("Only read the first `n` values of the set." first: Int "Only read the last `n` values of the set." last: Int "Skip the first `n` values from our `after` cursor, an alternative to cursor\nbased pagination. May not be used with `last`." offset: Int "Read all values in the set before (above) this cursor." before: Cursor "Read all values in the set after (below) this cursor." after: Cursor "The method to use when ordering `Vote`." orderBy: [VotesOrderBy!] = [ PRIMARY_KEY_ASC ] "A condition to be used in determining which values should be returned by the collection." condition: VoteCondition "A filter to be used in determining which values should be returned by the collection." filter: VoteFilter): VotesConnection
  "Reads and enables pagination through a set of `WorldRecordGlobal`."
  worldRecordGlobals("Only read the first `n` values of the set." first: Int "Only read the last `n` values of the set." last: Int "Skip the first `n` values from our `after` cursor, an alternative to cursor\nbased pagination. May not be used with `last`." offset: Int "Read all values in the set before (above) this cursor." before: Cursor "Read all values in the set after (below) this cursor." after: Cursor "The method to use when ordering `WorldRecordGlobal`." orderBy: [WorldRecordGlobalsOrderBy!] = [ PRIMARY_KEY_ASC ] "A condition to be used in determining which values should be returned by the collection." condition: WorldRecordGlobalCondition "A filter to be used in determining which values should be returned by the collection." filter: WorldRecordGlobalFilter): WorldRecordGlobalsConnection
  favourite(id: Int!): Favourite
  level(id: Int!): Level
  levelByHash(hash: String!): Level
  levelItem(id: Int!): LevelItem
  levelMetadatum(id: Int!): LevelMetadatum
  levelPoint(id: Int!): LevelPoint
  levelPointsHistory(id: Int!): LevelPointsHistory
  levelRequest(id: Int!): LevelRequest
  personalBestGlobal(id: Int!): PersonalBestGlobal
  record(id: Int!): Record
  recordMedia(id: Int!): RecordMedia
  recordMediaByRecordId(recordId: Int!): RecordMedia
  user(id: Int!): User
  userPoint(id: Int!): UserPoint
  userPointsHistory(id: Int!): UserPointsHistory
  version(id: Int!): Version
  vote(id: Int!): Vote
  worldRecordGlobal(id: Int!): WorldRecordGlobal
  "Retrieves filtered level items based on specified criteria."
  zRtm(pMinAuthorTime: Float pMaxAuthorTime: Float pMinRecords: Int pMaxRecords: Int pExcludedAuthorIds: [Int] pExcludedHashes: [String] pMinCheckpoints: Int pMaxCheckpoints: Int pMinFinishes: Int pMaxFinishes: Int pMinBlocks: Int pMaxBlocks: Int pSampleSize: Int "Only read the first `n` values of the set." first: Int "Only read the last `n` values of the set." last: Int "Skip the first `n` values from our `after` cursor, an alternative to cursor\nbased pagination. May not be used with `last`." offset: Int "Read all values in the set before (above) this cursor." before: Cursor "Read all values in the set after (below) this cursor." after: Cursor "A filter to be used in determining which values should be returned by the collection." filter: ZRtmRecordFilter): ZRtmConnection
  "Reads a single `Favourite` using its globally unique `ID`."
  favouriteByNodeId("The globally unique `ID` to be used in selecting a single `Favourite`." nodeId: ID!): Favourite
  "Reads a single `Level` using its globally unique `ID`."
  levelByNodeId("The globally unique `ID` to be used in selecting a single `Level`." nodeId: ID!): Level
  "Reads a single `LevelItem` using its globally unique `ID`."
  levelItemByNodeId("The globally unique `ID` to be used in selecting a single `LevelItem`." nodeId: ID!): LevelItem
  "Reads a single `LevelMetadatum` using its globally unique `ID`."
  levelMetadatumByNodeId("The globally unique `ID` to be used in selecting a single `LevelMetadatum`." nodeId: ID!): LevelMetadatum
  "Reads a single `LevelPoint` using its globally unique `ID`."
  levelPointByNodeId("The globally unique `ID` to be used in selecting a single `LevelPoint`." nodeId: ID!): LevelPoint
  "Reads a single `LevelPointsHistory` using its globally unique `ID`."
  levelPointsHistoryByNodeId("The globally unique `ID` to be used in selecting a single `LevelPointsHistory`." nodeId: ID!): LevelPointsHistory
  "Reads a single `LevelRequest` using its globally unique `ID`."
  levelRequestByNodeId("The globally unique `ID` to be used in selecting a single `LevelRequest`." nodeId: ID!): LevelRequest
  "Reads a single `PersonalBestGlobal` using its globally unique `ID`."
  personalBestGlobalByNodeId("The globally unique `ID` to be used in selecting a single `PersonalBestGlobal`." nodeId: ID!): PersonalBestGlobal
  "Reads a single `Record` using its globally unique `ID`."
  recordByNodeId("The globally unique `ID` to be used in selecting a single `Record`." nodeId: ID!): Record
  "Reads a single `RecordMedia` using its globally unique `ID`."
  recordMediaByNodeId("The globally unique `ID` to be used in selecting a single `RecordMedia`." nodeId: ID!): RecordMedia
  "Reads a single `User` using its globally unique `ID`."
  userByNodeId("The globally unique `ID` to be used in selecting a single `User`." nodeId: ID!): User
  "Reads a single `UserPoint` using its globally unique `ID`."
  userPointByNodeId("The globally unique `ID` to be used in selecting a single `UserPoint`." nodeId: ID!): UserPoint
  "Reads a single `UserPointsHistory` using its globally unique `ID`."
  userPointsHistoryByNodeId("The globally unique `ID` to be used in selecting a single `UserPointsHistory`." nodeId: ID!): UserPointsHistory
  "Reads a single `Version` using its globally unique `ID`."
  versionByNodeId("The globally unique `ID` to be used in selecting a single `Version`." nodeId: ID!): Version
  "Reads a single `Vote` using its globally unique `ID`."
  voteByNodeId("The globally unique `ID` to be used in selecting a single `Vote`." nodeId: ID!): Vote
  "Reads a single `WorldRecordGlobal` using its globally unique `ID`."
  worldRecordGlobalByNodeId("The globally unique `ID` to be used in selecting a single `WorldRecordGlobal`." nodeId: ID!): WorldRecordGlobal
}

"An object with a globally unique `ID`."
interface Node {
  "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
  nodeId: ID!
}

"A connection to a list of `Favourite` values."
type FavouritesConnection {
  "A list of `Favourite` objects."
  nodes: [Favourite!]!
  "A list of edges which contains the `Favourite` and cursor to aid in pagination."
  edges: [FavouritesEdge!]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `Favourite` you could get from the connection."
  totalCount: Int!
}

type Favourite implements Node {
  "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
  nodeId: ID!
  id: Int!
  userId: Int!
  dateCreated: Datetime!
  dateUpdated: Datetime
  levelId: Int!
  "Reads a single `User` that is related to this `Favourite`."
  user: User
  "Reads a single `Level` that is related to this `Favourite`."
  level: Level
}

"A point in time as described by the [ISO\n8601](https:\/\/en.wikipedia.org\/wiki\/ISO_8601) standard. May or may not include a timezone."
scalar Datetime

type User implements Node {
  "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
  nodeId: ID!
  id: Int!
  steamName: String
  banned: Boolean!
  dateCreated: Datetime!
  dateUpdated: Datetime
  steamId: BigInt
  discordId: BigInt
  "Reads and enables pagination through a set of `Favourite`."
  favourites("Only read the first `n` values of the set." first: Int "Only read the last `n` values of the set." last: Int "Skip the first `n` values from our `after` cursor, an alternative to cursor\nbased pagination. May not be used with `last`." offset: Int "Read all values in the set before (above) this cursor." before: Cursor "Read all values in the set after (below) this cursor." after: Cursor "The method to use when ordering `Favourite`." orderBy: [FavouritesOrderBy!] = [ PRIMARY_KEY_ASC ] "A condition to be used in determining which values should be returned by the collection." condition: FavouriteCondition "A filter to be used in determining which values should be returned by the collection." filter: FavouriteFilter): FavouritesConnection!
  "Reads and enables pagination through a set of `PersonalBestGlobal`."
  personalBestGlobals("Only read the first `n` values of the set." first: Int "Only read the last `n` values of the set." last: Int "Skip the first `n` values from our `after` cursor, an alternative to cursor\nbased pagination. May not be used with `last`." offset: Int "Read all values in the set before (above) this cursor." before: Cursor "Read all values in the set after (below) this cursor." after: Cursor "The method to use when ordering `PersonalBestGlobal`." orderBy: [PersonalBestGlobalsOrderBy!] = [ PRIMARY_KEY_ASC ] "A condition to be used in determining which values should be returned by the collection." condition: PersonalBestGlobalCondition "A filter to be used in determining which values should be returned by the collection." filter: PersonalBestGlobalFilter): PersonalBestGlobalsConnection!
  "Reads and enables pagination through a set of `UserPoint`."
  userPoints("Only read the first `n` values of the set." first: Int "Only read the last `n` values of the set." last: Int "Skip the first `n` values from our `after` cursor, an alternative to cursor\nbased pagination. May not be used with `last`." offset: Int "Read all values in the set before (above) this cursor." before: Cursor "Read all values in the set after (below) this cursor." after: Cursor "The method to use when ordering `UserPoint`." orderBy: [UserPointsOrderBy!] = [ PRIMARY_KEY_ASC ] "A condition to be used in determining which values should be returned by the collection." condition: UserPointCondition "A filter to be used in determining which values should be returned by the collection." filter: UserPointFilter): UserPointsConnection!
  "Reads and enables pagination through a set of `Record`."
  records("Only read the first `n` values of the set." first: Int "Only read the last `n` values of the set." last: Int "Skip the first `n` values from our `after` cursor, an alternative to cursor\nbased pagination. May not be used with `last`." offset: Int "Read all values in the set before (above) this cursor." before: Cursor "Read all values in the set after (below) this cursor." after: Cursor "The method to use when ordering `Record`." orderBy: [RecordsOrderBy!] = [ PRIMARY_KEY_ASC ] "A condition to be used in determining which values should be returned by the collection." condition: RecordCondition "A filter to be used in determining which values should be returned by the collection." filter: RecordFilter): RecordsConnection!
  "Reads and enables pagination through a set of `WorldRecordGlobal`."
  worldRecordGlobals("Only read the first `n` values of the set." first: Int "Only read the last `n` values of the set." last: Int "Skip the first `n` values from our `after` cursor, an alternative to cursor\nbased pagination. May not be used with `last`." offset: Int "Read all values in the set before (above) this cursor." before: Cursor "Read all values in the set after (below) this cursor." after: Cursor "The method to use when ordering `WorldRecordGlobal`." orderBy: [WorldRecordGlobalsOrderBy!] = [ PRIMARY_KEY_ASC ] "A condition to be used in determining which values should be returned by the collection." condition: WorldRecordGlobalCondition "A filter to be used in determining which values should be returned by the collection." filter: WorldRecordGlobalFilter): WorldRecordGlobalsConnection!
  "Reads and enables pagination through a set of `Vote`."
  votes("Only read the first `n` values of the set." first: Int "Only read the last `n` values of the set." last: Int "Skip the first `n` values from our `after` cursor, an alternative to cursor\nbased pagination. May not be used with `last`." offset: Int "Read all values in the set before (above) this cursor." before: Cursor "Read all values in the set after (below) this cursor." after: Cursor "The method to use when ordering `Vote`." orderBy: [VotesOrderBy!] = [ PRIMARY_KEY_ASC ] "A condition to be used in determining which values should be returned by the collection." condition: VoteCondition "A filter to be used in determining which values should be returned by the collection." filter: VoteFilter): VotesConnection!
  "Reads and enables pagination through a set of `UserPointsHistory`."
  userPointsHistories("Only read the first `n` values of the set." first: Int "Only read the last `n` values of the set." last: Int "Skip the first `n` values from our `after` cursor, an alternative to cursor\nbased pagination. May not be used with `last`." offset: Int "Read all values in the set before (above) this cursor." before: Cursor "Read all values in the set after (below) this cursor." after: Cursor "The method to use when ordering `UserPointsHistory`." orderBy: [UserPointsHistoriesOrderBy!] = [ PRIMARY_KEY_ASC ] "A condition to be used in determining which values should be returned by the collection." condition: UserPointsHistoryCondition "A filter to be used in determining which values should be returned by the collection." filter: UserPointsHistoryFilter): UserPointsHistoriesConnection!
  "Reads and enables pagination through a set of `Level`."
  levelsByFavourite("Only read the first `n` values of the set." first: Int "Only read the last `n` values of the set." last: Int "Skip the first `n` values from our `after` cursor, an alternative to cursor\nbased pagination. May not be used with `last`." offset: Int "Read all values in the set before (above) this cursor." before: Cursor "Read all values in the set after (below) this cursor." after: Cursor "The method to use when ordering `Level`." orderBy: [LevelsOrderBy!] = [ PRIMARY_KEY_ASC ] "A condition to be used in determining which values should be returned by the collection." condition: LevelCondition "A filter to be used in determining which values should be returned by the collection." filter: LevelFilter): UserLevelsByFavouriteManyToManyConnection!
  "Reads and enables pagination through a set of `Record`."
  recordsByPersonalBestGlobal("Only read the first `n` values of the set." first: Int "Only read the last `n` values of the set." last: Int "Skip the first `n` values from our `after` cursor, an alternative to cursor\nbased pagination. May not be used with `last`." offset: Int "Read all values in the set before (above) this cursor." before: Cursor "Read all values in the set after (below) this cursor." after: Cursor "The method to use when ordering `Record`." orderBy: [RecordsOrderBy!] = [ PRIMARY_KEY_ASC ] "A condition to be used in determining which values should be returned by the collection." condition: RecordCondition "A filter to be used in determining which values should be returned by the collection." filter: RecordFilter): UserRecordsByPersonalBestGlobalManyToManyConnection!
  "Reads and enables pagination through a set of `Level`."
  levelsByPersonalBestGlobal("Only read the first `n` values of the set." first: Int "Only read the last `n` values of the set." last: Int "Skip the first `n` values from our `after` cursor, an alternative to cursor\nbased pagination. May not be used with `last`." offset: Int "Read all values in the set before (above) this cursor." before: Cursor "Read all values in the set after (below) this cursor." after: Cursor "The method to use when ordering `Level`." orderBy: [LevelsOrderBy!] = [ PRIMARY_KEY_ASC ] "A condition to be used in determining which values should be returned by the collection." condition: LevelCondition "A filter to be used in determining which values should be returned by the collection." filter: LevelFilter): UserLevelsByPersonalBestGlobalManyToManyConnection!
  "Reads and enables pagination through a set of `Level`."
  levelsByRecord("Only read the first `n` values of the set." first: Int "Only read the last `n` values of the set." last: Int "Skip the first `n` values from our `after` cursor, an alternative to cursor\nbased pagination. May not be used with `last`." offset: Int "Read all values in the set before (above) this cursor." before: Cursor "Read all values in the set after (below) this cursor." after: Cursor "The method to use when ordering `Level`." orderBy: [LevelsOrderBy!] = [ PRIMARY_KEY_ASC ] "A condition to be used in determining which values should be returned by the collection." condition: LevelCondition "A filter to be used in determining which values should be returned by the collection." filter: LevelFilter): UserLevelsByRecordManyToManyConnection!
  "Reads and enables pagination through a set of `Record`."
  recordsByWorldRecordGlobal("Only read the first `n` values of the set." first: Int "Only read the last `n` values of the set." last: Int "Skip the first `n` values from our `after` cursor, an alternative to cursor\nbased pagination. May not be used with `last`." offset: Int "Read all values in the set before (above) this cursor." before: Cursor "Read all values in the set after (below) this cursor." after: Cursor "The method to use when ordering `Record`." orderBy: [RecordsOrderBy!] = [ PRIMARY_KEY_ASC ] "A condition to be used in determining which values should be returned by the collection." condition: RecordCondition "A filter to be used in determining which values should be returned by the collection." filter: RecordFilter): UserRecordsByWorldRecordGlobalManyToManyConnection!
  "Reads and enables pagination through a set of `Level`."
  levelsByWorldRecordGlobal("Only read the first `n` values of the set." first: Int "Only read the last `n` values of the set." last: Int "Skip the first `n` values from our `after` cursor, an alternative to cursor\nbased pagination. May not be used with `last`." offset: Int "Read all values in the set before (above) this cursor." before: Cursor "Read all values in the set after (below) this cursor." after: Cursor "The method to use when ordering `Level`." orderBy: [LevelsOrderBy!] = [ PRIMARY_KEY_ASC ] "A condition to be used in determining which values should be returned by the collection." condition: LevelCondition "A filter to be used in determining which values should be returned by the collection." filter: LevelFilter): UserLevelsByWorldRecordGlobalManyToManyConnection!
  "Reads and enables pagination through a set of `Level`."
  levelsByVote("Only read the first `n` values of the set." first: Int "Only read the last `n` values of the set." last: Int "Skip the first `n` values from our `after` cursor, an alternative to cursor\nbased pagination. May not be used with `last`." offset: Int "Read all values in the set before (above) this cursor." before: Cursor "Read all values in the set after (below) this cursor." after: Cursor "The method to use when ordering `Level`." orderBy: [LevelsOrderBy!] = [ PRIMARY_KEY_ASC ] "A condition to be used in determining which values should be returned by the collection." condition: LevelCondition "A filter to be used in determining which values should be returned by the collection." filter: LevelFilter): UserLevelsByVoteManyToManyConnection!
}

"A signed eight-byte integer. The upper big integer values are greater than the\nmax value for a JavaScript number. Therefore all big integers will be output as\nstrings and not numbers."
scalar BigInt

"A location in a connection that can be used for resuming pagination."
scalar Cursor

"Methods to use when ordering `Favourite`."
enum FavouritesOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  ID_USER_ASC
  ID_USER_DESC
  DATE_CREATED_ASC
  DATE_CREATED_DESC
  DATE_UPDATED_ASC
  DATE_UPDATED_DESC
  ID_LEVEL_ASC
  ID_LEVEL_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  USER_ID_ASC
  USER_ID_DESC
  USER_STEAM_NAME_ASC
  USER_STEAM_NAME_DESC
  USER_BANNED_ASC
  USER_BANNED_DESC
  USER_DATE_CREATED_ASC
  USER_DATE_CREATED_DESC
  USER_DATE_UPDATED_ASC
  USER_DATE_UPDATED_DESC
  USER_STEAM_ID_ASC
  USER_STEAM_ID_DESC
  USER_DISCORD_ID_ASC
  USER_DISCORD_ID_DESC
  LEVEL_ID_ASC
  LEVEL_ID_DESC
  LEVEL_HASH_ASC
  LEVEL_HASH_DESC
  LEVEL_DATE_CREATED_ASC
  LEVEL_DATE_CREATED_DESC
  LEVEL_DATE_UPDATED_ASC
  LEVEL_DATE_UPDATED_DESC
}

"A condition to be used against `Favourite` object types. All fields are tested\nfor equality and combined with a logical ‘and.’"
input FavouriteCondition {
  "Checks for equality with the object’s `id` field."
  id: Int
  "Checks for equality with the object’s `userId` field."
  userId: Int
  "Checks for equality with the object’s `dateCreated` field."
  dateCreated: Datetime
  "Checks for equality with the object’s `dateUpdated` field."
  dateUpdated: Datetime
  "Checks for equality with the object’s `levelId` field."
  levelId: Int
}

"A filter to be used against `Favourite` object types. All fields are combined with a logical ‘and.’"
input FavouriteFilter {
  "Filter by the object’s `id` field."
  id: IntFilter
  "Filter by the object’s `userId` field."
  userId: IntFilter
  "Filter by the object’s `dateCreated` field."
  dateCreated: DatetimeFilter
  "Filter by the object’s `dateUpdated` field."
  dateUpdated: DatetimeFilter
  "Filter by the object’s `levelId` field."
  levelId: IntFilter
  "Filter by the object’s `user` relation."
  user: UserFilter
  "Filter by the object’s `level` relation."
  level: LevelFilter
  "Checks for all expressions in this list."
  and: [FavouriteFilter!]
  "Checks for any expressions in this list."
  or: [FavouriteFilter!]
  "Negates the expression."
  not: FavouriteFilter
}

"A filter to be used against Int fields. All fields are combined with a logical ‘and.’"
input IntFilter {
  "Is null (if `true` is specified) or is not null (if `false` is specified)."
  isNull: Boolean
  "Equal to the specified value."
  equalTo: Int
  "Not equal to the specified value."
  notEqualTo: Int
  "Not equal to the specified value, treating null like an ordinary value."
  distinctFrom: Int
  "Equal to the specified value, treating null like an ordinary value."
  notDistinctFrom: Int
  "Included in the specified list."
  in: [Int!]
  "Not included in the specified list."
  notIn: [Int!]
  "Less than the specified value."
  lessThan: Int
  "Less than or equal to the specified value."
  lessThanOrEqualTo: Int
  "Greater than the specified value."
  greaterThan: Int
  "Greater than or equal to the specified value."
  greaterThanOrEqualTo: Int
}

"A filter to be used against Datetime fields. All fields are combined with a logical ‘and.’"
input DatetimeFilter {
  "Is null (if `true` is specified) or is not null (if `false` is specified)."
  isNull: Boolean
  "Equal to the specified value."
  equalTo: Datetime
  "Not equal to the specified value."
  notEqualTo: Datetime
  "Not equal to the specified value, treating null like an ordinary value."
  distinctFrom: Datetime
  "Equal to the specified value, treating null like an ordinary value."
  notDistinctFrom: Datetime
  "Included in the specified list."
  in: [Datetime!]
  "Not included in the specified list."
  notIn: [Datetime!]
  "Less than the specified value."
  lessThan: Datetime
  "Less than or equal to the specified value."
  lessThanOrEqualTo: Datetime
  "Greater than the specified value."
  greaterThan: Datetime
  "Greater than or equal to the specified value."
  greaterThanOrEqualTo: Datetime
}

"A filter to be used against `User` object types. All fields are combined with a logical ‘and.’"
input UserFilter {
  "Filter by the object’s `id` field."
  id: IntFilter
  "Filter by the object’s `steamName` field."
  steamName: StringFilter
  "Filter by the object’s `banned` field."
  banned: BooleanFilter
  "Filter by the object’s `dateCreated` field."
  dateCreated: DatetimeFilter
  "Filter by the object’s `dateUpdated` field."
  dateUpdated: DatetimeFilter
  "Filter by the object’s `steamId` field."
  steamId: BigIntFilter
  "Filter by the object’s `discordId` field."
  discordId: BigIntFilter
  "Filter by the object’s `favourites` relation."
  favourites: UserToManyFavouriteFilter
  "Some related `favourites` exist."
  favouritesExist: Boolean
  "Filter by the object’s `personalBestGlobals` relation."
  personalBestGlobals: UserToManyPersonalBestGlobalFilter
  "Some related `personalBestGlobals` exist."
  personalBestGlobalsExist: Boolean
  "Filter by the object’s `userPoints` relation."
  userPoints: UserToManyUserPointFilter
  "Some related `userPoints` exist."
  userPointsExist: Boolean
  "Filter by the object’s `records` relation."
  records: UserToManyRecordFilter
  "Some related `records` exist."
  recordsExist: Boolean
  "Filter by the object’s `worldRecordGlobals` relation."
  worldRecordGlobals: UserToManyWorldRecordGlobalFilter
  "Some related `worldRecordGlobals` exist."
  worldRecordGlobalsExist: Boolean
  "Filter by the object’s `votes` relation."
  votes: UserToManyVoteFilter
  "Some related `votes` exist."
  votesExist: Boolean
  "Filter by the object’s `userPointsHistories` relation."
  userPointsHistories: UserToManyUserPointsHistoryFilter
  "Some related `userPointsHistories` exist."
  userPointsHistoriesExist: Boolean
  "Checks for all expressions in this list."
  and: [UserFilter!]
  "Checks for any expressions in this list."
  or: [UserFilter!]
  "Negates the expression."
  not: UserFilter
}

"A filter to be used against String fields. All fields are combined with a logical ‘and.’"
input StringFilter {
  "Is null (if `true` is specified) or is not null (if `false` is specified)."
  isNull: Boolean
  "Equal to the specified value."
  equalTo: String
  "Not equal to the specified value."
  notEqualTo: String
  "Not equal to the specified value, treating null like an ordinary value."
  distinctFrom: String
  "Equal to the specified value, treating null like an ordinary value."
  notDistinctFrom: String
  "Included in the specified list."
  in: [String!]
  "Not included in the specified list."
  notIn: [String!]
  "Less than the specified value."
  lessThan: String
  "Less than or equal to the specified value."
  lessThanOrEqualTo: String
  "Greater than the specified value."
  greaterThan: String
  "Greater than or equal to the specified value."
  greaterThanOrEqualTo: String
  "Contains the specified string (case-sensitive)."
  includes: String
  "Does not contain the specified string (case-sensitive)."
  notIncludes: String
  "Contains the specified string (case-insensitive)."
  includesInsensitive: String
  "Does not contain the specified string (case-insensitive)."
  notIncludesInsensitive: String
  "Starts with the specified string (case-sensitive)."
  startsWith: String
  "Does not start with the specified string (case-sensitive)."
  notStartsWith: String
  "Starts with the specified string (case-insensitive)."
  startsWithInsensitive: String
  "Does not start with the specified string (case-insensitive)."
  notStartsWithInsensitive: String
  "Ends with the specified string (case-sensitive)."
  endsWith: String
  "Does not end with the specified string (case-sensitive)."
  notEndsWith: String
  "Ends with the specified string (case-insensitive)."
  endsWithInsensitive: String
  "Does not end with the specified string (case-insensitive)."
  notEndsWithInsensitive: String
  "Matches the specified pattern (case-sensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters."
  like: String
  "Does not match the specified pattern (case-sensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters."
  notLike: String
  "Matches the specified pattern (case-insensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters."
  likeInsensitive: String
  "Does not match the specified pattern (case-insensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters."
  notLikeInsensitive: String
  "Equal to the specified value (case-insensitive)."
  equalToInsensitive: String
  "Not equal to the specified value (case-insensitive)."
  notEqualToInsensitive: String
  "Not equal to the specified value, treating null like an ordinary value (case-insensitive)."
  distinctFromInsensitive: String
  "Equal to the specified value, treating null like an ordinary value (case-insensitive)."
  notDistinctFromInsensitive: String
  "Included in the specified list (case-insensitive)."
  inInsensitive: [String!]
  "Not included in the specified list (case-insensitive)."
  notInInsensitive: [String!]
  "Less than the specified value (case-insensitive)."
  lessThanInsensitive: String
  "Less than or equal to the specified value (case-insensitive)."
  lessThanOrEqualToInsensitive: String
  "Greater than the specified value (case-insensitive)."
  greaterThanInsensitive: String
  "Greater than or equal to the specified value (case-insensitive)."
  greaterThanOrEqualToInsensitive: String
}

"A filter to be used against Boolean fields. All fields are combined with a logical ‘and.’"
input BooleanFilter {
  "Is null (if `true` is specified) or is not null (if `false` is specified)."
  isNull: Boolean
  "Equal to the specified value."
  equalTo: Boolean
  "Not equal to the specified value."
  notEqualTo: Boolean
  "Not equal to the specified value, treating null like an ordinary value."
  distinctFrom: Boolean
  "Equal to the specified value, treating null like an ordinary value."
  notDistinctFrom: Boolean
  "Included in the specified list."
  in: [Boolean!]
  "Not included in the specified list."
  notIn: [Boolean!]
  "Less than the specified value."
  lessThan: Boolean
  "Less than or equal to the specified value."
  lessThanOrEqualTo: Boolean
  "Greater than the specified value."
  greaterThan: Boolean
  "Greater than or equal to the specified value."
  greaterThanOrEqualTo: Boolean
}

"A filter to be used against BigInt fields. All fields are combined with a logical ‘and.’"
input BigIntFilter {
  "Is null (if `true` is specified) or is not null (if `false` is specified)."
  isNull: Boolean
  "Equal to the specified value."
  equalTo: BigInt
  "Not equal to the specified value."
  notEqualTo: BigInt
  "Not equal to the specified value, treating null like an ordinary value."
  distinctFrom: BigInt
  "Equal to the specified value, treating null like an ordinary value."
  notDistinctFrom: BigInt
  "Included in the specified list."
  in: [BigInt!]
  "Not included in the specified list."
  notIn: [BigInt!]
  "Less than the specified value."
  lessThan: BigInt
  "Less than or equal to the specified value."
  lessThanOrEqualTo: BigInt
  "Greater than the specified value."
  greaterThan: BigInt
  "Greater than or equal to the specified value."
  greaterThanOrEqualTo: BigInt
}

"A filter to be used against many `Favourite` object types. All fields are combined with a logical ‘and.’"
input UserToManyFavouriteFilter {
  "Every related `Favourite` matches the filter criteria. All fields are combined with a logical ‘and.’"
  every: FavouriteFilter
  "Some related `Favourite` matches the filter criteria. All fields are combined with a logical ‘and.’"
  some: FavouriteFilter
  "No related `Favourite` matches the filter criteria. All fields are combined with a logical ‘and.’"
  none: FavouriteFilter
}

"A filter to be used against many `PersonalBestGlobal` object types. All fields are combined with a logical ‘and.’"
input UserToManyPersonalBestGlobalFilter {
  "Every related `PersonalBestGlobal` matches the filter criteria. All fields are combined with a logical ‘and.’"
  every: PersonalBestGlobalFilter
  "Some related `PersonalBestGlobal` matches the filter criteria. All fields are combined with a logical ‘and.’"
  some: PersonalBestGlobalFilter
  "No related `PersonalBestGlobal` matches the filter criteria. All fields are combined with a logical ‘and.’"
  none: PersonalBestGlobalFilter
}

"A filter to be used against `PersonalBestGlobal` object types. All fields are combined with a logical ‘and.’"
input PersonalBestGlobalFilter {
  "Filter by the object’s `id` field."
  id: IntFilter
  "Filter by the object’s `recordId` field."
  recordId: IntFilter
  "Filter by the object’s `userId` field."
  userId: IntFilter
  "Filter by the object’s `levelId` field."
  levelId: IntFilter
  "Filter by the object’s `dateCreated` field."
  dateCreated: DatetimeFilter
  "Filter by the object’s `dateUpdated` field."
  dateUpdated: DatetimeFilter
  "Filter by the object’s `record` relation."
  record: RecordFilter
  "Filter by the object’s `user` relation."
  user: UserFilter
  "Filter by the object’s `level` relation."
  level: LevelFilter
  "Checks for all expressions in this list."
  and: [PersonalBestGlobalFilter!]
  "Checks for any expressions in this list."
  or: [PersonalBestGlobalFilter!]
  "Negates the expression."
  not: PersonalBestGlobalFilter
}

"A filter to be used against `Record` object types. All fields are combined with a logical ‘and.’"
input RecordFilter {
  "Filter by the object’s `id` field."
  id: IntFilter
  "Filter by the object’s `userId` field."
  userId: IntFilter
  "Filter by the object’s `time` field."
  time: FloatFilter
  "Filter by the object’s `gameVersion` field."
  gameVersion: StringFilter
  "Filter by the object’s `levelId` field."
  levelId: IntFilter
  "Filter by the object’s `modVersion` field."
  modVersion: StringFilter
  "Filter by the object’s `dateCreated` field."
  dateCreated: DatetimeFilter
  "Filter by the object’s `dateUpdated` field."
  dateUpdated: DatetimeFilter
  "Filter by the object’s `splits` field."
  splits: FloatListFilter
  "Filter by the object’s `speeds` field."
  speeds: FloatListFilter
  "Filter by the object’s `recordMedia` relation."
  recordMedia: RecordMediaFilter
  "A related `recordMedia` exists."
  recordMediaExists: Boolean
  "Filter by the object’s `personalBestGlobals` relation."
  personalBestGlobals: RecordToManyPersonalBestGlobalFilter
  "Some related `personalBestGlobals` exist."
  personalBestGlobalsExist: Boolean
  "Filter by the object’s `worldRecordGlobals` relation."
  worldRecordGlobals: RecordToManyWorldRecordGlobalFilter
  "Some related `worldRecordGlobals` exist."
  worldRecordGlobalsExist: Boolean
  "Filter by the object’s `user` relation."
  user: UserFilter
  "Filter by the object’s `level` relation."
  level: LevelFilter
  "Checks for all expressions in this list."
  and: [RecordFilter!]
  "Checks for any expressions in this list."
  or: [RecordFilter!]
  "Negates the expression."
  not: RecordFilter
}

"A filter to be used against Float fields. All fields are combined with a logical ‘and.’"
input FloatFilter {
  "Is null (if `true` is specified) or is not null (if `false` is specified)."
  isNull: Boolean
  "Equal to the specified value."
  equalTo: Float
  "Not equal to the specified value."
  notEqualTo: Float
  "Not equal to the specified value, treating null like an ordinary value."
  distinctFrom: Float
  "Equal to the specified value, treating null like an ordinary value."
  notDistinctFrom: Float
  "Included in the specified list."
  in: [Float!]
  "Not included in the specified list."
  notIn: [Float!]
  "Less than the specified value."
  lessThan: Float
  "Less than or equal to the specified value."
  lessThanOrEqualTo: Float
  "Greater than the specified value."
  greaterThan: Float
  "Greater than or equal to the specified value."
  greaterThanOrEqualTo: Float
}

"A filter to be used against Float List fields. All fields are combined with a logical ‘and.’"
input FloatListFilter {
  "Is null (if `true` is specified) or is not null (if `false` is specified)."
  isNull: Boolean
  "Equal to the specified value."
  equalTo: [Float]
  "Not equal to the specified value."
  notEqualTo: [Float]
  "Not equal to the specified value, treating null like an ordinary value."
  distinctFrom: [Float]
  "Equal to the specified value, treating null like an ordinary value."
  notDistinctFrom: [Float]
  "Less than the specified value."
  lessThan: [Float]
  "Less than or equal to the specified value."
  lessThanOrEqualTo: [Float]
  "Greater than the specified value."
  greaterThan: [Float]
  "Greater than or equal to the specified value."
  greaterThanOrEqualTo: [Float]
  "Contains the specified list of values."
  contains: [Float]
  "Contained by the specified list of values."
  containedBy: [Float]
  "Overlaps the specified list of values."
  overlaps: [Float]
  "Any array item is equal to the specified value."
  anyEqualTo: Float
  "Any array item is not equal to the specified value."
  anyNotEqualTo: Float
  "Any array item is less than the specified value."
  anyLessThan: Float
  "Any array item is less than or equal to the specified value."
  anyLessThanOrEqualTo: Float
  "Any array item is greater than the specified value."
  anyGreaterThan: Float
  "Any array item is greater than or equal to the specified value."
  anyGreaterThanOrEqualTo: Float
}

"A filter to be used against `RecordMedia` object types. All fields are combined with a logical ‘and.’"
input RecordMediaFilter {
  "Filter by the object’s `id` field."
  id: IntFilter
  "Filter by the object’s `recordId` field."
  recordId: IntFilter
  "Filter by the object’s `ghostUrl` field."
  ghostUrl: StringFilter
  "Filter by the object’s `dateCreated` field."
  dateCreated: DatetimeFilter
  "Filter by the object’s `dateUpdated` field."
  dateUpdated: DatetimeFilter
  "Filter by the object’s `record` relation."
  record: RecordFilter
  "Checks for all expressions in this list."
  and: [RecordMediaFilter!]
  "Checks for any expressions in this list."
  or: [RecordMediaFilter!]
  "Negates the expression."
  not: RecordMediaFilter
}

"A filter to be used against many `PersonalBestGlobal` object types. All fields are combined with a logical ‘and.’"
input RecordToManyPersonalBestGlobalFilter {
  "Every related `PersonalBestGlobal` matches the filter criteria. All fields are combined with a logical ‘and.’"
  every: PersonalBestGlobalFilter
  "Some related `PersonalBestGlobal` matches the filter criteria. All fields are combined with a logical ‘and.’"
  some: PersonalBestGlobalFilter
  "No related `PersonalBestGlobal` matches the filter criteria. All fields are combined with a logical ‘and.’"
  none: PersonalBestGlobalFilter
}

"A filter to be used against many `WorldRecordGlobal` object types. All fields are combined with a logical ‘and.’"
input RecordToManyWorldRecordGlobalFilter {
  "Every related `WorldRecordGlobal` matches the filter criteria. All fields are combined with a logical ‘and.’"
  every: WorldRecordGlobalFilter
  "Some related `WorldRecordGlobal` matches the filter criteria. All fields are combined with a logical ‘and.’"
  some: WorldRecordGlobalFilter
  "No related `WorldRecordGlobal` matches the filter criteria. All fields are combined with a logical ‘and.’"
  none: WorldRecordGlobalFilter
}

"A filter to be used against `WorldRecordGlobal` object types. All fields are combined with a logical ‘and.’"
input WorldRecordGlobalFilter {
  "Filter by the object’s `id` field."
  id: IntFilter
  "Filter by the object’s `recordId` field."
  recordId: IntFilter
  "Filter by the object’s `levelId` field."
  levelId: IntFilter
  "Filter by the object’s `dateCreated` field."
  dateCreated: DatetimeFilter
  "Filter by the object’s `dateUpdated` field."
  dateUpdated: DatetimeFilter
  "Filter by the object’s `userId` field."
  userId: IntFilter
  "Filter by the object’s `record` relation."
  record: RecordFilter
  "Filter by the object’s `level` relation."
  level: LevelFilter
  "Filter by the object’s `user` relation."
  user: UserFilter
  "Checks for all expressions in this list."
  and: [WorldRecordGlobalFilter!]
  "Checks for any expressions in this list."
  or: [WorldRecordGlobalFilter!]
  "Negates the expression."
  not: WorldRecordGlobalFilter
}

"A filter to be used against `Level` object types. All fields are combined with a logical ‘and.’"
input LevelFilter {
  "Filter by the object’s `id` field."
  id: IntFilter
  "Filter by the object’s `hash` field."
  hash: StringFilter
  "Filter by the object’s `dateCreated` field."
  dateCreated: DatetimeFilter
  "Filter by the object’s `dateUpdated` field."
  dateUpdated: DatetimeFilter
  "Filter by the object’s `favourites` relation."
  favourites: LevelToManyFavouriteFilter
  "Some related `favourites` exist."
  favouritesExist: Boolean
  "Filter by the object’s `levelItems` relation."
  levelItems: LevelToManyLevelItemFilter
  "Some related `levelItems` exist."
  levelItemsExist: Boolean
  "Filter by the object’s `levelMetadata` relation."
  levelMetadata: LevelToManyLevelMetadatumFilter
  "Some related `levelMetadata` exist."
  levelMetadataExist: Boolean
  "Filter by the object’s `levelPoints` relation."
  levelPoints: LevelToManyLevelPointFilter
  "Some related `levelPoints` exist."
  levelPointsExist: Boolean
  "Filter by the object’s `personalBestGlobals` relation."
  personalBestGlobals: LevelToManyPersonalBestGlobalFilter
  "Some related `personalBestGlobals` exist."
  personalBestGlobalsExist: Boolean
  "Filter by the object’s `records` relation."
  records: LevelToManyRecordFilter
  "Some related `records` exist."
  recordsExist: Boolean
  "Filter by the object’s `worldRecordGlobals` relation."
  worldRecordGlobals: LevelToManyWorldRecordGlobalFilter
  "Some related `worldRecordGlobals` exist."
  worldRecordGlobalsExist: Boolean
  "Filter by the object’s `votes` relation."
  votes: LevelToManyVoteFilter
  "Some related `votes` exist."
  votesExist: Boolean
  "Filter by the object’s `levelPointsHistories` relation."
  levelPointsHistories: LevelToManyLevelPointsHistoryFilter
  "Some related `levelPointsHistories` exist."
  levelPointsHistoriesExist: Boolean
  "Checks for all expressions in this list."
  and: [LevelFilter!]
  "Checks for any expressions in this list."
  or: [LevelFilter!]
  "Negates the expression."
  not: LevelFilter
}

"A filter to be used against many `Favourite` object types. All fields are combined with a logical ‘and.’"
input LevelToManyFavouriteFilter {
  "Every related `Favourite` matches the filter criteria. All fields are combined with a logical ‘and.’"
  every: FavouriteFilter
  "Some related `Favourite` matches the filter criteria. All fields are combined with a logical ‘and.’"
  some: FavouriteFilter
  "No related `Favourite` matches the filter criteria. All fields are combined with a logical ‘and.’"
  none: FavouriteFilter
}

"A filter to be used against many `LevelItem` object types. All fields are combined with a logical ‘and.’"
input LevelToManyLevelItemFilter {
  "Every related `LevelItem` matches the filter criteria. All fields are combined with a logical ‘and.’"
  every: LevelItemFilter
  "Some related `LevelItem` matches the filter criteria. All fields are combined with a logical ‘and.’"
  some: LevelItemFilter
  "No related `LevelItem` matches the filter criteria. All fields are combined with a logical ‘and.’"
  none: LevelItemFilter
}

"A filter to be used against `LevelItem` object types. All fields are combined with a logical ‘and.’"
input LevelItemFilter {
  "Filter by the object’s `id` field."
  id: IntFilter
  "Filter by the object’s `levelId` field."
  levelId: IntFilter
  "Filter by the object’s `workshopId` field."
  workshopId: BigFloatFilter
  "Filter by the object’s `authorId` field."
  authorId: BigFloatFilter
  "Filter by the object’s `name` field."
  name: StringFilter
  "Filter by the object’s `imageUrl` field."
  imageUrl: StringFilter
  "Filter by the object’s `fileAuthor` field."
  fileAuthor: StringFilter
  "Filter by the object’s `fileUid` field."
  fileUid: StringFilter
  "Filter by the object’s `validationTimeAuthor` field."
  validationTimeAuthor: FloatFilter
  "Filter by the object’s `validationTimeGold` field."
  validationTimeGold: FloatFilter
  "Filter by the object’s `validationTimeSilver` field."
  validationTimeSilver: FloatFilter
  "Filter by the object’s `validationTimeBronze` field."
  validationTimeBronze: FloatFilter
  "Filter by the object’s `deleted` field."
  deleted: BooleanFilter
  "Filter by the object’s `createdAt` field."
  createdAt: DatetimeFilter
  "Filter by the object’s `updatedAt` field."
  updatedAt: DatetimeFilter
  "Filter by the object’s `dateCreated` field."
  dateCreated: DatetimeFilter
  "Filter by the object’s `dateUpdated` field."
  dateUpdated: DatetimeFilter
  "Filter by the object’s `level` relation."
  level: LevelFilter
  "Checks for all expressions in this list."
  and: [LevelItemFilter!]
  "Checks for any expressions in this list."
  or: [LevelItemFilter!]
  "Negates the expression."
  not: LevelItemFilter
}

"A filter to be used against BigFloat fields. All fields are combined with a logical ‘and.’"
input BigFloatFilter {
  "Is null (if `true` is specified) or is not null (if `false` is specified)."
  isNull: Boolean
  "Equal to the specified value."
  equalTo: BigFloat
  "Not equal to the specified value."
  notEqualTo: BigFloat
  "Not equal to the specified value, treating null like an ordinary value."
  distinctFrom: BigFloat
  "Equal to the specified value, treating null like an ordinary value."
  notDistinctFrom: BigFloat
  "Included in the specified list."
  in: [BigFloat!]
  "Not included in the specified list."
  notIn: [BigFloat!]
  "Less than the specified value."
  lessThan: BigFloat
  "Less than or equal to the specified value."
  lessThanOrEqualTo: BigFloat
  "Greater than the specified value."
  greaterThan: BigFloat
  "Greater than or equal to the specified value."
  greaterThanOrEqualTo: BigFloat
}

"A floating point number that requires more precision than IEEE 754 binary 64"
scalar BigFloat

"A filter to be used against many `LevelMetadatum` object types. All fields are combined with a logical ‘and.’"
input LevelToManyLevelMetadatumFilter {
  "Every related `LevelMetadatum` matches the filter criteria. All fields are combined with a logical ‘and.’"
  every: LevelMetadatumFilter
  "Some related `LevelMetadatum` matches the filter criteria. All fields are combined with a logical ‘and.’"
  some: LevelMetadatumFilter
  "No related `LevelMetadatum` matches the filter criteria. All fields are combined with a logical ‘and.’"
  none: LevelMetadatumFilter
}

"A filter to be used against `LevelMetadatum` object types. All fields are combined with a logical ‘and.’"
input LevelMetadatumFilter {
  "Filter by the object’s `id` field."
  id: IntFilter
  "Filter by the object’s `levelId` field."
  levelId: IntFilter
  "Filter by the object’s `amountCheckpoints` field."
  amountCheckpoints: IntFilter
  "Filter by the object’s `amountFinishes` field."
  amountFinishes: IntFilter
  "Filter by the object’s `amountBlocks` field."
  amountBlocks: IntFilter
  "Filter by the object’s `typeGround` field."
  typeGround: IntFilter
  "Filter by the object’s `typeSkybox` field."
  typeSkybox: IntFilter
  "Filter by the object’s `blocks` field."
  blocks: JSONFilter
  "Filter by the object’s `dateCreated` field."
  dateCreated: DatetimeFilter
  "Filter by the object’s `dateUpdated` field."
  dateUpdated: DatetimeFilter
  "Filter by the object’s `level` relation."
  level: LevelFilter
  "Checks for all expressions in this list."
  and: [LevelMetadatumFilter!]
  "Checks for any expressions in this list."
  or: [LevelMetadatumFilter!]
  "Negates the expression."
  not: LevelMetadatumFilter
}

"A filter to be used against JSON fields. All fields are combined with a logical ‘and.’"
input JSONFilter {
  "Is null (if `true` is specified) or is not null (if `false` is specified)."
  isNull: Boolean
  "Equal to the specified value."
  equalTo: JSON
  "Not equal to the specified value."
  notEqualTo: JSON
  "Not equal to the specified value, treating null like an ordinary value."
  distinctFrom: JSON
  "Equal to the specified value, treating null like an ordinary value."
  notDistinctFrom: JSON
  "Included in the specified list."
  in: [JSON!]
  "Not included in the specified list."
  notIn: [JSON!]
  "Less than the specified value."
  lessThan: JSON
  "Less than or equal to the specified value."
  lessThanOrEqualTo: JSON
  "Greater than the specified value."
  greaterThan: JSON
  "Greater than or equal to the specified value."
  greaterThanOrEqualTo: JSON
  "Contains the specified JSON."
  contains: JSON
  "Contains the specified key."
  containsKey: String
  "Contains all of the specified keys."
  containsAllKeys: [String!]
  "Contains any of the specified keys."
  containsAnyKeys: [String!]
  "Contained by the specified JSON."
  containedBy: JSON
}

"A JavaScript object encoded in the JSON format as specified by [ECMA-404](http:\/\/www.ecma-international.org\/publications\/files\/ECMA-ST\/ECMA-404.pdf)."
scalar JSON

"A filter to be used against many `LevelPoint` object types. All fields are combined with a logical ‘and.’"
input LevelToManyLevelPointFilter {
  "Every related `LevelPoint` matches the filter criteria. All fields are combined with a logical ‘and.’"
  every: LevelPointFilter
  "Some related `LevelPoint` matches the filter criteria. All fields are combined with a logical ‘and.’"
  some: LevelPointFilter
  "No related `LevelPoint` matches the filter criteria. All fields are combined with a logical ‘and.’"
  none: LevelPointFilter
}

"A filter to be used against `LevelPoint` object types. All fields are combined with a logical ‘and.’"
input LevelPointFilter {
  "Filter by the object’s `id` field."
  id: IntFilter
  "Filter by the object’s `points` field."
  points: IntFilter
  "Filter by the object’s `levelId` field."
  levelId: IntFilter
  "Filter by the object’s `dateCreated` field."
  dateCreated: DatetimeFilter
  "Filter by the object’s `dateUpdated` field."
  dateUpdated: DatetimeFilter
  "Filter by the object’s `level` relation."
  level: LevelFilter
  "Checks for all expressions in this list."
  and: [LevelPointFilter!]
  "Checks for any expressions in this list."
  or: [LevelPointFilter!]
  "Negates the expression."
  not: LevelPointFilter
}

"A filter to be used against many `PersonalBestGlobal` object types. All fields are combined with a logical ‘and.’"
input LevelToManyPersonalBestGlobalFilter {
  "Every related `PersonalBestGlobal` matches the filter criteria. All fields are combined with a logical ‘and.’"
  every: PersonalBestGlobalFilter
  "Some related `PersonalBestGlobal` matches the filter criteria. All fields are combined with a logical ‘and.’"
  some: PersonalBestGlobalFilter
  "No related `PersonalBestGlobal` matches the filter criteria. All fields are combined with a logical ‘and.’"
  none: PersonalBestGlobalFilter
}

"A filter to be used against many `Record` object types. All fields are combined with a logical ‘and.’"
input LevelToManyRecordFilter {
  "Every related `Record` matches the filter criteria. All fields are combined with a logical ‘and.’"
  every: RecordFilter
  "Some related `Record` matches the filter criteria. All fields are combined with a logical ‘and.’"
  some: RecordFilter
  "No related `Record` matches the filter criteria. All fields are combined with a logical ‘and.’"
  none: RecordFilter
}

"A filter to be used against many `WorldRecordGlobal` object types. All fields are combined with a logical ‘and.’"
input LevelToManyWorldRecordGlobalFilter {
  "Every related `WorldRecordGlobal` matches the filter criteria. All fields are combined with a logical ‘and.’"
  every: WorldRecordGlobalFilter
  "Some related `WorldRecordGlobal` matches the filter criteria. All fields are combined with a logical ‘and.’"
  some: WorldRecordGlobalFilter
  "No related `WorldRecordGlobal` matches the filter criteria. All fields are combined with a logical ‘and.’"
  none: WorldRecordGlobalFilter
}

"A filter to be used against many `Vote` object types. All fields are combined with a logical ‘and.’"
input LevelToManyVoteFilter {
  "Every related `Vote` matches the filter criteria. All fields are combined with a logical ‘and.’"
  every: VoteFilter
  "Some related `Vote` matches the filter criteria. All fields are combined with a logical ‘and.’"
  some: VoteFilter
  "No related `Vote` matches the filter criteria. All fields are combined with a logical ‘and.’"
  none: VoteFilter
}

"A filter to be used against `Vote` object types. All fields are combined with a logical ‘and.’"
input VoteFilter {
  "Filter by the object’s `id` field."
  id: IntFilter
  "Filter by the object’s `userId` field."
  userId: IntFilter
  "Filter by the object’s `levelId` field."
  levelId: IntFilter
  "Filter by the object’s `value` field."
  value: IntFilter
  "Filter by the object’s `dateCreated` field."
  dateCreated: DatetimeFilter
  "Filter by the object’s `dateUpdated` field."
  dateUpdated: DatetimeFilter
  "Filter by the object’s `user` relation."
  user: UserFilter
  "Filter by the object’s `level` relation."
  level: LevelFilter
  "Checks for all expressions in this list."
  and: [VoteFilter!]
  "Checks for any expressions in this list."
  or: [VoteFilter!]
  "Negates the expression."
  not: VoteFilter
}

"A filter to be used against many `LevelPointsHistory` object types. All fields are combined with a logical ‘and.’"
input LevelToManyLevelPointsHistoryFilter {
  "Every related `LevelPointsHistory` matches the filter criteria. All fields are combined with a logical ‘and.’"
  every: LevelPointsHistoryFilter
  "Some related `LevelPointsHistory` matches the filter criteria. All fields are combined with a logical ‘and.’"
  some: LevelPointsHistoryFilter
  "No related `LevelPointsHistory` matches the filter criteria. All fields are combined with a logical ‘and.’"
  none: LevelPointsHistoryFilter
}

"A filter to be used against `LevelPointsHistory` object types. All fields are combined with a logical ‘and.’"
input LevelPointsHistoryFilter {
  "Filter by the object’s `id` field."
  id: IntFilter
  "Filter by the object’s `levelId` field."
  levelId: IntFilter
  "Filter by the object’s `points` field."
  points: IntFilter
  "Filter by the object’s `dateCreated` field."
  dateCreated: DatetimeFilter
  "Filter by the object’s `level` relation."
  level: LevelFilter
  "Checks for all expressions in this list."
  and: [LevelPointsHistoryFilter!]
  "Checks for any expressions in this list."
  or: [LevelPointsHistoryFilter!]
  "Negates the expression."
  not: LevelPointsHistoryFilter
}

"A filter to be used against many `UserPoint` object types. All fields are combined with a logical ‘and.’"
input UserToManyUserPointFilter {
  "Every related `UserPoint` matches the filter criteria. All fields are combined with a logical ‘and.’"
  every: UserPointFilter
  "Some related `UserPoint` matches the filter criteria. All fields are combined with a logical ‘and.’"
  some: UserPointFilter
  "No related `UserPoint` matches the filter criteria. All fields are combined with a logical ‘and.’"
  none: UserPointFilter
}

"A filter to be used against `UserPoint` object types. All fields are combined with a logical ‘and.’"
input UserPointFilter {
  "Filter by the object’s `id` field."
  id: IntFilter
  "Filter by the object’s `userId` field."
  userId: IntFilter
  "Filter by the object’s `points` field."
  points: IntFilter
  "Filter by the object’s `dateCreated` field."
  dateCreated: DatetimeFilter
  "Filter by the object’s `dateUpdated` field."
  dateUpdated: DatetimeFilter
  "Filter by the object’s `rank` field."
  rank: IntFilter
  "Filter by the object’s `worldRecords` field."
  worldRecords: IntFilter
  "Filter by the object’s `totalPoints` field."
  totalPoints: IntFilter
  "Filter by the object’s `user` relation."
  user: UserFilter
  "Checks for all expressions in this list."
  and: [UserPointFilter!]
  "Checks for any expressions in this list."
  or: [UserPointFilter!]
  "Negates the expression."
  not: UserPointFilter
}

"A filter to be used against many `Record` object types. All fields are combined with a logical ‘and.’"
input UserToManyRecordFilter {
  "Every related `Record` matches the filter criteria. All fields are combined with a logical ‘and.’"
  every: RecordFilter
  "Some related `Record` matches the filter criteria. All fields are combined with a logical ‘and.’"
  some: RecordFilter
  "No related `Record` matches the filter criteria. All fields are combined with a logical ‘and.’"
  none: RecordFilter
}

"A filter to be used against many `WorldRecordGlobal` object types. All fields are combined with a logical ‘and.’"
input UserToManyWorldRecordGlobalFilter {
  "Every related `WorldRecordGlobal` matches the filter criteria. All fields are combined with a logical ‘and.’"
  every: WorldRecordGlobalFilter
  "Some related `WorldRecordGlobal` matches the filter criteria. All fields are combined with a logical ‘and.’"
  some: WorldRecordGlobalFilter
  "No related `WorldRecordGlobal` matches the filter criteria. All fields are combined with a logical ‘and.’"
  none: WorldRecordGlobalFilter
}

"A filter to be used against many `Vote` object types. All fields are combined with a logical ‘and.’"
input UserToManyVoteFilter {
  "Every related `Vote` matches the filter criteria. All fields are combined with a logical ‘and.’"
  every: VoteFilter
  "Some related `Vote` matches the filter criteria. All fields are combined with a logical ‘and.’"
  some: VoteFilter
  "No related `Vote` matches the filter criteria. All fields are combined with a logical ‘and.’"
  none: VoteFilter
}

"A filter to be used against many `UserPointsHistory` object types. All fields are combined with a logical ‘and.’"
input UserToManyUserPointsHistoryFilter {
  "Every related `UserPointsHistory` matches the filter criteria. All fields are combined with a logical ‘and.’"
  every: UserPointsHistoryFilter
  "Some related `UserPointsHistory` matches the filter criteria. All fields are combined with a logical ‘and.’"
  some: UserPointsHistoryFilter
  "No related `UserPointsHistory` matches the filter criteria. All fields are combined with a logical ‘and.’"
  none: UserPointsHistoryFilter
}

"A filter to be used against `UserPointsHistory` object types. All fields are combined with a logical ‘and.’"
input UserPointsHistoryFilter {
  "Filter by the object’s `id` field."
  id: IntFilter
  "Filter by the object’s `userId` field."
  userId: IntFilter
  "Filter by the object’s `points` field."
  points: IntFilter
  "Filter by the object’s `totalPoints` field."
  totalPoints: IntFilter
  "Filter by the object’s `rank` field."
  rank: IntFilter
  "Filter by the object’s `worldRecords` field."
  worldRecords: IntFilter
  "Filter by the object’s `dateCreated` field."
  dateCreated: DatetimeFilter
  "Filter by the object’s `user` relation."
  user: UserFilter
  "Checks for all expressions in this list."
  and: [UserPointsHistoryFilter!]
  "Checks for any expressions in this list."
  or: [UserPointsHistoryFilter!]
  "Negates the expression."
  not: UserPointsHistoryFilter
}

"A connection to a list of `PersonalBestGlobal` values."
type PersonalBestGlobalsConnection {
  "A list of `PersonalBestGlobal` objects."
  nodes: [PersonalBestGlobal!]!
  "A list of edges which contains the `PersonalBestGlobal` and cursor to aid in pagination."
  edges: [PersonalBestGlobalsEdge!]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `PersonalBestGlobal` you could get from the connection."
  totalCount: Int!
}

type PersonalBestGlobal implements Node {
  "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
  nodeId: ID!
  id: Int!
  recordId: Int!
  userId: Int!
  levelId: Int!
  dateCreated: Datetime!
  dateUpdated: Datetime
  "Reads a single `Record` that is related to this `PersonalBestGlobal`."
  record: Record
  "Reads a single `User` that is related to this `PersonalBestGlobal`."
  user: User
  "Reads a single `Level` that is related to this `PersonalBestGlobal`."
  level: Level
}

type Record implements Node {
  "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
  nodeId: ID!
  id: Int!
  userId: Int!
  time: Float!
  gameVersion: String!
  levelId: Int!
  modVersion: String!
  dateCreated: Datetime!
  dateUpdated: Datetime
  splits: [Float]
  speeds: [Float]
  "Reads a single `User` that is related to this `Record`."
  user: User
  "Reads a single `Level` that is related to this `Record`."
  level: Level
  "Reads a single `RecordMedia` that is related to this `Record`."
  recordMedia: RecordMedia
  "Reads and enables pagination through a set of `RecordMedia`."
  recordMedias("Only read the first `n` values of the set." first: Int "Only read the last `n` values of the set." last: Int "Skip the first `n` values from our `after` cursor, an alternative to cursor\nbased pagination. May not be used with `last`." offset: Int "Read all values in the set before (above) this cursor." before: Cursor "Read all values in the set after (below) this cursor." after: Cursor "The method to use when ordering `RecordMedia`." orderBy: [RecordMediaOrderBy!] = [ PRIMARY_KEY_ASC ] "A condition to be used in determining which values should be returned by the collection." condition: RecordMediaCondition "A filter to be used in determining which values should be returned by the collection." filter: RecordMediaFilter): RecordMediaConnection! @deprecated(reason: "Please use recordMedia instead")
  "Reads and enables pagination through a set of `PersonalBestGlobal`."
  personalBestGlobals("Only read the first `n` values of the set." first: Int "Only read the last `n` values of the set." last: Int "Skip the first `n` values from our `after` cursor, an alternative to cursor\nbased pagination. May not be used with `last`." offset: Int "Read all values in the set before (above) this cursor." before: Cursor "Read all values in the set after (below) this cursor." after: Cursor "The method to use when ordering `PersonalBestGlobal`." orderBy: [PersonalBestGlobalsOrderBy!] = [ PRIMARY_KEY_ASC ] "A condition to be used in determining which values should be returned by the collection." condition: PersonalBestGlobalCondition "A filter to be used in determining which values should be returned by the collection." filter: PersonalBestGlobalFilter): PersonalBestGlobalsConnection!
  "Reads and enables pagination through a set of `WorldRecordGlobal`."
  worldRecordGlobals("Only read the first `n` values of the set." first: Int "Only read the last `n` values of the set." last: Int "Skip the first `n` values from our `after` cursor, an alternative to cursor\nbased pagination. May not be used with `last`." offset: Int "Read all values in the set before (above) this cursor." before: Cursor "Read all values in the set after (below) this cursor." after: Cursor "The method to use when ordering `WorldRecordGlobal`." orderBy: [WorldRecordGlobalsOrderBy!] = [ PRIMARY_KEY_ASC ] "A condition to be used in determining which values should be returned by the collection." condition: WorldRecordGlobalCondition "A filter to be used in determining which values should be returned by the collection." filter: WorldRecordGlobalFilter): WorldRecordGlobalsConnection!
  "Reads and enables pagination through a set of `User`."
  usersByPersonalBestGlobal("Only read the first `n` values of the set." first: Int "Only read the last `n` values of the set." last: Int "Skip the first `n` values from our `after` cursor, an alternative to cursor\nbased pagination. May not be used with `last`." offset: Int "Read all values in the set before (above) this cursor." before: Cursor "Read all values in the set after (below) this cursor." after: Cursor "The method to use when ordering `User`." orderBy: [UsersOrderBy!] = [ PRIMARY_KEY_ASC ] "A condition to be used in determining which values should be returned by the collection." condition: UserCondition "A filter to be used in determining which values should be returned by the collection." filter: UserFilter): RecordUsersByPersonalBestGlobalManyToManyConnection!
  "Reads and enables pagination through a set of `Level`."
  levelsByPersonalBestGlobal("Only read the first `n` values of the set." first: Int "Only read the last `n` values of the set." last: Int "Skip the first `n` values from our `after` cursor, an alternative to cursor\nbased pagination. May not be used with `last`." offset: Int "Read all values in the set before (above) this cursor." before: Cursor "Read all values in the set after (below) this cursor." after: Cursor "The method to use when ordering `Level`." orderBy: [LevelsOrderBy!] = [ PRIMARY_KEY_ASC ] "A condition to be used in determining which values should be returned by the collection." condition: LevelCondition "A filter to be used in determining which values should be returned by the collection." filter: LevelFilter): RecordLevelsByPersonalBestGlobalManyToManyConnection!
  "Reads and enables pagination through a set of `Level`."
  levelsByWorldRecordGlobal("Only read the first `n` values of the set." first: Int "Only read the last `n` values of the set." last: Int "Skip the first `n` values from our `after` cursor, an alternative to cursor\nbased pagination. May not be used with `last`." offset: Int "Read all values in the set before (above) this cursor." before: Cursor "Read all values in the set after (below) this cursor." after: Cursor "The method to use when ordering `Level`." orderBy: [LevelsOrderBy!] = [ PRIMARY_KEY_ASC ] "A condition to be used in determining which values should be returned by the collection." condition: LevelCondition "A filter to be used in determining which values should be returned by the collection." filter: LevelFilter): RecordLevelsByWorldRecordGlobalManyToManyConnection!
  "Reads and enables pagination through a set of `User`."
  usersByWorldRecordGlobal("Only read the first `n` values of the set." first: Int "Only read the last `n` values of the set." last: Int "Skip the first `n` values from our `after` cursor, an alternative to cursor\nbased pagination. May not be used with `last`." offset: Int "Read all values in the set before (above) this cursor." before: Cursor "Read all values in the set after (below) this cursor." after: Cursor "The method to use when ordering `User`." orderBy: [UsersOrderBy!] = [ PRIMARY_KEY_ASC ] "A condition to be used in determining which values should be returned by the collection." condition: UserCondition "A filter to be used in determining which values should be returned by the collection." filter: UserFilter): RecordUsersByWorldRecordGlobalManyToManyConnection!
}

type Level implements Node {
  "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
  nodeId: ID!
  id: Int!
  hash: String!
  dateCreated: Datetime!
  dateUpdated: Datetime
  "Reads and enables pagination through a set of `Favourite`."
  favourites("Only read the first `n` values of the set." first: Int "Only read the last `n` values of the set." last: Int "Skip the first `n` values from our `after` cursor, an alternative to cursor\nbased pagination. May not be used with `last`." offset: Int "Read all values in the set before (above) this cursor." before: Cursor "Read all values in the set after (below) this cursor." after: Cursor "The method to use when ordering `Favourite`." orderBy: [FavouritesOrderBy!] = [ PRIMARY_KEY_ASC ] "A condition to be used in determining which values should be returned by the collection." condition: FavouriteCondition "A filter to be used in determining which values should be returned by the collection." filter: FavouriteFilter): FavouritesConnection!
  "Reads and enables pagination through a set of `LevelItem`."
  levelItems("Only read the first `n` values of the set." first: Int "Only read the last `n` values of the set." last: Int "Skip the first `n` values from our `after` cursor, an alternative to cursor\nbased pagination. May not be used with `last`." offset: Int "Read all values in the set before (above) this cursor." before: Cursor "Read all values in the set after (below) this cursor." after: Cursor "The method to use when ordering `LevelItem`." orderBy: [LevelItemsOrderBy!] = [ PRIMARY_KEY_ASC ] "A condition to be used in determining which values should be returned by the collection." condition: LevelItemCondition "A filter to be used in determining which values should be returned by the collection." filter: LevelItemFilter): LevelItemsConnection!
  "Reads and enables pagination through a set of `LevelMetadatum`."
  levelMetadata("Only read the first `n` values of the set." first: Int "Only read the last `n` values of the set." last: Int "Skip the first `n` values from our `after` cursor, an alternative to cursor\nbased pagination. May not be used with `last`." offset: Int "Read all values in the set before (above) this cursor." before: Cursor "Read all values in the set after (below) this cursor." after: Cursor "The method to use when ordering `LevelMetadatum`." orderBy: [LevelMetadataOrderBy!] = [ PRIMARY_KEY_ASC ] "A condition to be used in determining which values should be returned by the collection." condition: LevelMetadatumCondition "A filter to be used in determining which values should be returned by the collection." filter: LevelMetadatumFilter): LevelMetadataConnection!
  "Reads and enables pagination through a set of `LevelPoint`."
  levelPoints("Only read the first `n` values of the set." first: Int "Only read the last `n` values of the set." last: Int "Skip the first `n` values from our `after` cursor, an alternative to cursor\nbased pagination. May not be used with `last`." offset: Int "Read all values in the set before (above) this cursor." before: Cursor "Read all values in the set after (below) this cursor." after: Cursor "The method to use when ordering `LevelPoint`." orderBy: [LevelPointsOrderBy!] = [ PRIMARY_KEY_ASC ] "A condition to be used in determining which values should be returned by the collection." condition: LevelPointCondition "A filter to be used in determining which values should be returned by the collection." filter: LevelPointFilter): LevelPointsConnection!
  "Reads and enables pagination through a set of `PersonalBestGlobal`."
  personalBestGlobals("Only read the first `n` values of the set." first: Int "Only read the last `n` values of the set." last: Int "Skip the first `n` values from our `after` cursor, an alternative to cursor\nbased pagination. May not be used with `last`." offset: Int "Read all values in the set before (above) this cursor." before: Cursor "Read all values in the set after (below) this cursor." after: Cursor "The method to use when ordering `PersonalBestGlobal`." orderBy: [PersonalBestGlobalsOrderBy!] = [ PRIMARY_KEY_ASC ] "A condition to be used in determining which values should be returned by the collection." condition: PersonalBestGlobalCondition "A filter to be used in determining which values should be returned by the collection." filter: PersonalBestGlobalFilter): PersonalBestGlobalsConnection!
  "Reads and enables pagination through a set of `Record`."
  records("Only read the first `n` values of the set." first: Int "Only read the last `n` values of the set." last: Int "Skip the first `n` values from our `after` cursor, an alternative to cursor\nbased pagination. May not be used with `last`." offset: Int "Read all values in the set before (above) this cursor." before: Cursor "Read all values in the set after (below) this cursor." after: Cursor "The method to use when ordering `Record`." orderBy: [RecordsOrderBy!] = [ PRIMARY_KEY_ASC ] "A condition to be used in determining which values should be returned by the collection." condition: RecordCondition "A filter to be used in determining which values should be returned by the collection." filter: RecordFilter): RecordsConnection!
  "Reads and enables pagination through a set of `WorldRecordGlobal`."
  worldRecordGlobals("Only read the first `n` values of the set." first: Int "Only read the last `n` values of the set." last: Int "Skip the first `n` values from our `after` cursor, an alternative to cursor\nbased pagination. May not be used with `last`." offset: Int "Read all values in the set before (above) this cursor." before: Cursor "Read all values in the set after (below) this cursor." after: Cursor "The method to use when ordering `WorldRecordGlobal`." orderBy: [WorldRecordGlobalsOrderBy!] = [ PRIMARY_KEY_ASC ] "A condition to be used in determining which values should be returned by the collection." condition: WorldRecordGlobalCondition "A filter to be used in determining which values should be returned by the collection." filter: WorldRecordGlobalFilter): WorldRecordGlobalsConnection!
  "Reads and enables pagination through a set of `Vote`."
  votes("Only read the first `n` values of the set." first: Int "Only read the last `n` values of the set." last: Int "Skip the first `n` values from our `after` cursor, an alternative to cursor\nbased pagination. May not be used with `last`." offset: Int "Read all values in the set before (above) this cursor." before: Cursor "Read all values in the set after (below) this cursor." after: Cursor "The method to use when ordering `Vote`." orderBy: [VotesOrderBy!] = [ PRIMARY_KEY_ASC ] "A condition to be used in determining which values should be returned by the collection." condition: VoteCondition "A filter to be used in determining which values should be returned by the collection." filter: VoteFilter): VotesConnection!
  "Reads and enables pagination through a set of `LevelPointsHistory`."
  levelPointsHistories("Only read the first `n` values of the set." first: Int "Only read the last `n` values of the set." last: Int "Skip the first `n` values from our `after` cursor, an alternative to cursor\nbased pagination. May not be used with `last`." offset: Int "Read all values in the set before (above) this cursor." before: Cursor "Read all values in the set after (below) this cursor." after: Cursor "The method to use when ordering `LevelPointsHistory`." orderBy: [LevelPointsHistoriesOrderBy!] = [ PRIMARY_KEY_ASC ] "A condition to be used in determining which values should be returned by the collection." condition: LevelPointsHistoryCondition "A filter to be used in determining which values should be returned by the collection." filter: LevelPointsHistoryFilter): LevelPointsHistoriesConnection!
  "Reads and enables pagination through a set of `User`."
  usersByFavourite("Only read the first `n` values of the set." first: Int "Only read the last `n` values of the set." last: Int "Skip the first `n` values from our `after` cursor, an alternative to cursor\nbased pagination. May not be used with `last`." offset: Int "Read all values in the set before (above) this cursor." before: Cursor "Read all values in the set after (below) this cursor." after: Cursor "The method to use when ordering `User`." orderBy: [UsersOrderBy!] = [ PRIMARY_KEY_ASC ] "A condition to be used in determining which values should be returned by the collection." condition: UserCondition "A filter to be used in determining which values should be returned by the collection." filter: UserFilter): LevelUsersByFavouriteManyToManyConnection!
  "Reads and enables pagination through a set of `Record`."
  recordsByPersonalBestGlobal("Only read the first `n` values of the set." first: Int "Only read the last `n` values of the set." last: Int "Skip the first `n` values from our `after` cursor, an alternative to cursor\nbased pagination. May not be used with `last`." offset: Int "Read all values in the set before (above) this cursor." before: Cursor "Read all values in the set after (below) this cursor." after: Cursor "The method to use when ordering `Record`." orderBy: [RecordsOrderBy!] = [ PRIMARY_KEY_ASC ] "A condition to be used in determining which values should be returned by the collection." condition: RecordCondition "A filter to be used in determining which values should be returned by the collection." filter: RecordFilter): LevelRecordsByPersonalBestGlobalManyToManyConnection!
  "Reads and enables pagination through a set of `User`."
  usersByPersonalBestGlobal("Only read the first `n` values of the set." first: Int "Only read the last `n` values of the set." last: Int "Skip the first `n` values from our `after` cursor, an alternative to cursor\nbased pagination. May not be used with `last`." offset: Int "Read all values in the set before (above) this cursor." before: Cursor "Read all values in the set after (below) this cursor." after: Cursor "The method to use when ordering `User`." orderBy: [UsersOrderBy!] = [ PRIMARY_KEY_ASC ] "A condition to be used in determining which values should be returned by the collection." condition: UserCondition "A filter to be used in determining which values should be returned by the collection." filter: UserFilter): LevelUsersByPersonalBestGlobalManyToManyConnection!
  "Reads and enables pagination through a set of `User`."
  usersByRecord("Only read the first `n` values of the set." first: Int "Only read the last `n` values of the set." last: Int "Skip the first `n` values from our `after` cursor, an alternative to cursor\nbased pagination. May not be used with `last`." offset: Int "Read all values in the set before (above) this cursor." before: Cursor "Read all values in the set after (below) this cursor." after: Cursor "The method to use when ordering `User`." orderBy: [UsersOrderBy!] = [ PRIMARY_KEY_ASC ] "A condition to be used in determining which values should be returned by the collection." condition: UserCondition "A filter to be used in determining which values should be returned by the collection." filter: UserFilter): LevelUsersByRecordManyToManyConnection!
  "Reads and enables pagination through a set of `Record`."
  recordsByWorldRecordGlobal("Only read the first `n` values of the set." first: Int "Only read the last `n` values of the set." last: Int "Skip the first `n` values from our `after` cursor, an alternative to cursor\nbased pagination. May not be used with `last`." offset: Int "Read all values in the set before (above) this cursor." before: Cursor "Read all values in the set after (below) this cursor." after: Cursor "The method to use when ordering `Record`." orderBy: [RecordsOrderBy!] = [ PRIMARY_KEY_ASC ] "A condition to be used in determining which values should be returned by the collection." condition: RecordCondition "A filter to be used in determining which values should be returned by the collection." filter: RecordFilter): LevelRecordsByWorldRecordGlobalManyToManyConnection!
  "Reads and enables pagination through a set of `User`."
  usersByWorldRecordGlobal("Only read the first `n` values of the set." first: Int "Only read the last `n` values of the set." last: Int "Skip the first `n` values from our `after` cursor, an alternative to cursor\nbased pagination. May not be used with `last`." offset: Int "Read all values in the set before (above) this cursor." before: Cursor "Read all values in the set after (below) this cursor." after: Cursor "The method to use when ordering `User`." orderBy: [UsersOrderBy!] = [ PRIMARY_KEY_ASC ] "A condition to be used in determining which values should be returned by the collection." condition: UserCondition "A filter to be used in determining which values should be returned by the collection." filter: UserFilter): LevelUsersByWorldRecordGlobalManyToManyConnection!
  "Reads and enables pagination through a set of `User`."
  usersByVote("Only read the first `n` values of the set." first: Int "Only read the last `n` values of the set." last: Int "Skip the first `n` values from our `after` cursor, an alternative to cursor\nbased pagination. May not be used with `last`." offset: Int "Read all values in the set before (above) this cursor." before: Cursor "Read all values in the set after (below) this cursor." after: Cursor "The method to use when ordering `User`." orderBy: [UsersOrderBy!] = [ PRIMARY_KEY_ASC ] "A condition to be used in determining which values should be returned by the collection." condition: UserCondition "A filter to be used in determining which values should be returned by the collection." filter: UserFilter): LevelUsersByVoteManyToManyConnection!
}

"A connection to a list of `LevelItem` values."
type LevelItemsConnection {
  "A list of `LevelItem` objects."
  nodes: [LevelItem!]!
  "A list of edges which contains the `LevelItem` and cursor to aid in pagination."
  edges: [LevelItemsEdge!]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `LevelItem` you could get from the connection."
  totalCount: Int!
}

type LevelItem implements Node {
  "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
  nodeId: ID!
  id: Int!
  levelId: Int!
  workshopId: BigFloat!
  authorId: BigFloat!
  name: String!
  imageUrl: String!
  fileAuthor: String!
  fileUid: String!
  validationTimeAuthor: Float!
  validationTimeGold: Float!
  validationTimeSilver: Float!
  validationTimeBronze: Float!
  deleted: Boolean!
  createdAt: Datetime!
  updatedAt: Datetime!
  dateCreated: Datetime!
  dateUpdated: Datetime
  "Reads a single `Level` that is related to this `LevelItem`."
  level: Level
}

"A `LevelItem` edge in the connection."
type LevelItemsEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `LevelItem` at the end of the edge."
  node: LevelItem!
}

"Information about pagination in a connection."
type PageInfo {
  "When paginating forwards, are there more items?"
  hasNextPage: Boolean!
  "When paginating backwards, are there more items?"
  hasPreviousPage: Boolean!
  "When paginating backwards, the cursor to continue."
  startCursor: Cursor
  "When paginating forwards, the cursor to continue."
  endCursor: Cursor
}

"Methods to use when ordering `LevelItem`."
enum LevelItemsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  ID_LEVEL_ASC
  ID_LEVEL_DESC
  WORKSHOP_ID_ASC
  WORKSHOP_ID_DESC
  AUTHOR_ID_ASC
  AUTHOR_ID_DESC
  NAME_ASC
  NAME_DESC
  IMAGE_URL_ASC
  IMAGE_URL_DESC
  FILE_AUTHOR_ASC
  FILE_AUTHOR_DESC
  FILE_UID_ASC
  FILE_UID_DESC
  VALIDATION_TIME_AUTHOR_ASC
  VALIDATION_TIME_AUTHOR_DESC
  VALIDATION_TIME_GOLD_ASC
  VALIDATION_TIME_GOLD_DESC
  VALIDATION_TIME_SILVER_ASC
  VALIDATION_TIME_SILVER_DESC
  VALIDATION_TIME_BRONZE_ASC
  VALIDATION_TIME_BRONZE_DESC
  DELETED_ASC
  DELETED_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  DATE_CREATED_ASC
  DATE_CREATED_DESC
  DATE_UPDATED_ASC
  DATE_UPDATED_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  LEVEL_ID_ASC
  LEVEL_ID_DESC
  LEVEL_HASH_ASC
  LEVEL_HASH_DESC
  LEVEL_DATE_CREATED_ASC
  LEVEL_DATE_CREATED_DESC
  LEVEL_DATE_UPDATED_ASC
  LEVEL_DATE_UPDATED_DESC
}

"A condition to be used against `LevelItem` object types. All fields are tested\nfor equality and combined with a logical ‘and.’"
input LevelItemCondition {
  "Checks for equality with the object’s `id` field."
  id: Int
  "Checks for equality with the object’s `levelId` field."
  levelId: Int
  "Checks for equality with the object’s `workshopId` field."
  workshopId: BigFloat
  "Checks for equality with the object’s `authorId` field."
  authorId: BigFloat
  "Checks for equality with the object’s `name` field."
  name: String
  "Checks for equality with the object’s `imageUrl` field."
  imageUrl: String
  "Checks for equality with the object’s `fileAuthor` field."
  fileAuthor: String
  "Checks for equality with the object’s `fileUid` field."
  fileUid: String
  "Checks for equality with the object’s `validationTimeAuthor` field."
  validationTimeAuthor: Float
  "Checks for equality with the object’s `validationTimeGold` field."
  validationTimeGold: Float
  "Checks for equality with the object’s `validationTimeSilver` field."
  validationTimeSilver: Float
  "Checks for equality with the object’s `validationTimeBronze` field."
  validationTimeBronze: Float
  "Checks for equality with the object’s `deleted` field."
  deleted: Boolean
  "Checks for equality with the object’s `createdAt` field."
  createdAt: Datetime
  "Checks for equality with the object’s `updatedAt` field."
  updatedAt: Datetime
  "Checks for equality with the object’s `dateCreated` field."
  dateCreated: Datetime
  "Checks for equality with the object’s `dateUpdated` field."
  dateUpdated: Datetime
}

"A connection to a list of `LevelMetadatum` values."
type LevelMetadataConnection {
  "A list of `LevelMetadatum` objects."
  nodes: [LevelMetadatum!]!
  "A list of edges which contains the `LevelMetadatum` and cursor to aid in pagination."
  edges: [LevelMetadataEdge!]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `LevelMetadatum` you could get from the connection."
  totalCount: Int!
}

type LevelMetadatum implements Node {
  "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
  nodeId: ID!
  id: Int!
  levelId: Int!
  amountCheckpoints: Int!
  amountFinishes: Int!
  amountBlocks: Int!
  typeGround: Int!
  typeSkybox: Int!
  blocks: JSON!
  dateCreated: Datetime!
  dateUpdated: Datetime
  "Reads a single `Level` that is related to this `LevelMetadatum`."
  level: Level
}

"A `LevelMetadatum` edge in the connection."
type LevelMetadataEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `LevelMetadatum` at the end of the edge."
  node: LevelMetadatum!
}

"Methods to use when ordering `LevelMetadatum`."
enum LevelMetadataOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  ID_LEVEL_ASC
  ID_LEVEL_DESC
  AMOUNT_CHECKPOINTS_ASC
  AMOUNT_CHECKPOINTS_DESC
  AMOUNT_FINISHES_ASC
  AMOUNT_FINISHES_DESC
  AMOUNT_BLOCKS_ASC
  AMOUNT_BLOCKS_DESC
  TYPE_GROUND_ASC
  TYPE_GROUND_DESC
  TYPE_SKYBOX_ASC
  TYPE_SKYBOX_DESC
  BLOCKS_ASC
  BLOCKS_DESC
  DATE_CREATED_ASC
  DATE_CREATED_DESC
  DATE_UPDATED_ASC
  DATE_UPDATED_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  LEVEL_ID_ASC
  LEVEL_ID_DESC
  LEVEL_HASH_ASC
  LEVEL_HASH_DESC
  LEVEL_DATE_CREATED_ASC
  LEVEL_DATE_CREATED_DESC
  LEVEL_DATE_UPDATED_ASC
  LEVEL_DATE_UPDATED_DESC
}

"A condition to be used against `LevelMetadatum` object types. All fields are\ntested for equality and combined with a logical ‘and.’"
input LevelMetadatumCondition {
  "Checks for equality with the object’s `id` field."
  id: Int
  "Checks for equality with the object’s `levelId` field."
  levelId: Int
  "Checks for equality with the object’s `amountCheckpoints` field."
  amountCheckpoints: Int
  "Checks for equality with the object’s `amountFinishes` field."
  amountFinishes: Int
  "Checks for equality with the object’s `amountBlocks` field."
  amountBlocks: Int
  "Checks for equality with the object’s `typeGround` field."
  typeGround: Int
  "Checks for equality with the object’s `typeSkybox` field."
  typeSkybox: Int
  "Checks for equality with the object’s `blocks` field."
  blocks: JSON
  "Checks for equality with the object’s `dateCreated` field."
  dateCreated: Datetime
  "Checks for equality with the object’s `dateUpdated` field."
  dateUpdated: Datetime
}

"A connection to a list of `LevelPoint` values."
type LevelPointsConnection {
  "A list of `LevelPoint` objects."
  nodes: [LevelPoint!]!
  "A list of edges which contains the `LevelPoint` and cursor to aid in pagination."
  edges: [LevelPointsEdge!]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `LevelPoint` you could get from the connection."
  totalCount: Int!
}

type LevelPoint implements Node {
  "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
  nodeId: ID!
  id: Int!
  points: Int!
  levelId: Int!
  dateCreated: Datetime!
  dateUpdated: Datetime
  "Reads a single `Level` that is related to this `LevelPoint`."
  level: Level
}

"A `LevelPoint` edge in the connection."
type LevelPointsEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `LevelPoint` at the end of the edge."
  node: LevelPoint!
}

"Methods to use when ordering `LevelPoint`."
enum LevelPointsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  POINTS_ASC
  POINTS_DESC
  ID_LEVEL_ASC
  ID_LEVEL_DESC
  DATE_CREATED_ASC
  DATE_CREATED_DESC
  DATE_UPDATED_ASC
  DATE_UPDATED_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  LEVEL_ID_ASC
  LEVEL_ID_DESC
  LEVEL_HASH_ASC
  LEVEL_HASH_DESC
  LEVEL_DATE_CREATED_ASC
  LEVEL_DATE_CREATED_DESC
  LEVEL_DATE_UPDATED_ASC
  LEVEL_DATE_UPDATED_DESC
}

"A condition to be used against `LevelPoint` object types. All fields are tested\nfor equality and combined with a logical ‘and.’"
input LevelPointCondition {
  "Checks for equality with the object’s `id` field."
  id: Int
  "Checks for equality with the object’s `points` field."
  points: Int
  "Checks for equality with the object’s `levelId` field."
  levelId: Int
  "Checks for equality with the object’s `dateCreated` field."
  dateCreated: Datetime
  "Checks for equality with the object’s `dateUpdated` field."
  dateUpdated: Datetime
}

"Methods to use when ordering `PersonalBestGlobal`."
enum PersonalBestGlobalsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  ID_RECORD_ASC
  ID_RECORD_DESC
  ID_USER_ASC
  ID_USER_DESC
  ID_LEVEL_ASC
  ID_LEVEL_DESC
  DATE_CREATED_ASC
  DATE_CREATED_DESC
  DATE_UPDATED_ASC
  DATE_UPDATED_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  RECORD_ID_ASC
  RECORD_ID_DESC
  RECORD_ID_USER_ASC
  RECORD_ID_USER_DESC
  RECORD_TIME_ASC
  RECORD_TIME_DESC
  RECORD_GAME_VERSION_ASC
  RECORD_GAME_VERSION_DESC
  RECORD_ID_LEVEL_ASC
  RECORD_ID_LEVEL_DESC
  RECORD_MOD_VERSION_ASC
  RECORD_MOD_VERSION_DESC
  RECORD_DATE_CREATED_ASC
  RECORD_DATE_CREATED_DESC
  RECORD_DATE_UPDATED_ASC
  RECORD_DATE_UPDATED_DESC
  RECORD_SPLITS_ASC
  RECORD_SPLITS_DESC
  RECORD_SPEEDS_ASC
  RECORD_SPEEDS_DESC
  USER_ID_ASC
  USER_ID_DESC
  USER_STEAM_NAME_ASC
  USER_STEAM_NAME_DESC
  USER_BANNED_ASC
  USER_BANNED_DESC
  USER_DATE_CREATED_ASC
  USER_DATE_CREATED_DESC
  USER_DATE_UPDATED_ASC
  USER_DATE_UPDATED_DESC
  USER_STEAM_ID_ASC
  USER_STEAM_ID_DESC
  USER_DISCORD_ID_ASC
  USER_DISCORD_ID_DESC
  LEVEL_ID_ASC
  LEVEL_ID_DESC
  LEVEL_HASH_ASC
  LEVEL_HASH_DESC
  LEVEL_DATE_CREATED_ASC
  LEVEL_DATE_CREATED_DESC
  LEVEL_DATE_UPDATED_ASC
  LEVEL_DATE_UPDATED_DESC
}

"A condition to be used against `PersonalBestGlobal` object types. All fields are\ntested for equality and combined with a logical ‘and.’"
input PersonalBestGlobalCondition {
  "Checks for equality with the object’s `id` field."
  id: Int
  "Checks for equality with the object’s `recordId` field."
  recordId: Int
  "Checks for equality with the object’s `userId` field."
  userId: Int
  "Checks for equality with the object’s `levelId` field."
  levelId: Int
  "Checks for equality with the object’s `dateCreated` field."
  dateCreated: Datetime
  "Checks for equality with the object’s `dateUpdated` field."
  dateUpdated: Datetime
}

"A connection to a list of `Record` values."
type RecordsConnection {
  "A list of `Record` objects."
  nodes: [Record!]!
  "A list of edges which contains the `Record` and cursor to aid in pagination."
  edges: [RecordsEdge!]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `Record` you could get from the connection."
  totalCount: Int!
}

"A `Record` edge in the connection."
type RecordsEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `Record` at the end of the edge."
  node: Record!
}

"Methods to use when ordering `Record`."
enum RecordsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  ID_USER_ASC
  ID_USER_DESC
  TIME_ASC
  TIME_DESC
  GAME_VERSION_ASC
  GAME_VERSION_DESC
  ID_LEVEL_ASC
  ID_LEVEL_DESC
  MOD_VERSION_ASC
  MOD_VERSION_DESC
  DATE_CREATED_ASC
  DATE_CREATED_DESC
  DATE_UPDATED_ASC
  DATE_UPDATED_DESC
  SPLITS_ASC
  SPLITS_DESC
  SPEEDS_ASC
  SPEEDS_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  USER_ID_ASC
  USER_ID_DESC
  USER_STEAM_NAME_ASC
  USER_STEAM_NAME_DESC
  USER_BANNED_ASC
  USER_BANNED_DESC
  USER_DATE_CREATED_ASC
  USER_DATE_CREATED_DESC
  USER_DATE_UPDATED_ASC
  USER_DATE_UPDATED_DESC
  USER_STEAM_ID_ASC
  USER_STEAM_ID_DESC
  USER_DISCORD_ID_ASC
  USER_DISCORD_ID_DESC
  LEVEL_ID_ASC
  LEVEL_ID_DESC
  LEVEL_HASH_ASC
  LEVEL_HASH_DESC
  LEVEL_DATE_CREATED_ASC
  LEVEL_DATE_CREATED_DESC
  LEVEL_DATE_UPDATED_ASC
  LEVEL_DATE_UPDATED_DESC
  RECORD_MEDIA_ID_ASC
  RECORD_MEDIA_ID_DESC
  RECORD_MEDIA_ID_RECORD_ASC
  RECORD_MEDIA_ID_RECORD_DESC
  RECORD_MEDIA_GHOST_URL_ASC
  RECORD_MEDIA_GHOST_URL_DESC
  RECORD_MEDIA_DATE_CREATED_ASC
  RECORD_MEDIA_DATE_CREATED_DESC
  RECORD_MEDIA_DATE_UPDATED_ASC
  RECORD_MEDIA_DATE_UPDATED_DESC
  PERSONAL_BEST_GLOBAL_COUNT_ASC
  PERSONAL_BEST_GLOBAL_COUNT_DESC
  PERSONAL_BEST_GLOBAL_MAX_ID_ASC
  PERSONAL_BEST_GLOBAL_MAX_ID_DESC
  PERSONAL_BEST_GLOBAL_MIN_ID_ASC
  PERSONAL_BEST_GLOBAL_MIN_ID_DESC
  PERSONAL_BEST_GLOBAL_MAX_ID_RECORD_ASC
  PERSONAL_BEST_GLOBAL_MAX_ID_RECORD_DESC
  PERSONAL_BEST_GLOBAL_MIN_ID_RECORD_ASC
  PERSONAL_BEST_GLOBAL_MIN_ID_RECORD_DESC
  PERSONAL_BEST_GLOBAL_MAX_ID_USER_ASC
  PERSONAL_BEST_GLOBAL_MAX_ID_USER_DESC
  PERSONAL_BEST_GLOBAL_MIN_ID_USER_ASC
  PERSONAL_BEST_GLOBAL_MIN_ID_USER_DESC
  PERSONAL_BEST_GLOBAL_MAX_ID_LEVEL_ASC
  PERSONAL_BEST_GLOBAL_MAX_ID_LEVEL_DESC
  PERSONAL_BEST_GLOBAL_MIN_ID_LEVEL_ASC
  PERSONAL_BEST_GLOBAL_MIN_ID_LEVEL_DESC
  PERSONAL_BEST_GLOBAL_MAX_DATE_CREATED_ASC
  PERSONAL_BEST_GLOBAL_MAX_DATE_CREATED_DESC
  PERSONAL_BEST_GLOBAL_MIN_DATE_CREATED_ASC
  PERSONAL_BEST_GLOBAL_MIN_DATE_CREATED_DESC
  PERSONAL_BEST_GLOBAL_MAX_DATE_UPDATED_ASC
  PERSONAL_BEST_GLOBAL_MAX_DATE_UPDATED_DESC
  PERSONAL_BEST_GLOBAL_MIN_DATE_UPDATED_ASC
  PERSONAL_BEST_GLOBAL_MIN_DATE_UPDATED_DESC
  WORLD_RECORD_GLOBAL_COUNT_ASC
  WORLD_RECORD_GLOBAL_COUNT_DESC
  WORLD_RECORD_GLOBAL_MAX_ID_ASC
  WORLD_RECORD_GLOBAL_MAX_ID_DESC
  WORLD_RECORD_GLOBAL_MIN_ID_ASC
  WORLD_RECORD_GLOBAL_MIN_ID_DESC
  WORLD_RECORD_GLOBAL_MAX_ID_RECORD_ASC
  WORLD_RECORD_GLOBAL_MAX_ID_RECORD_DESC
  WORLD_RECORD_GLOBAL_MIN_ID_RECORD_ASC
  WORLD_RECORD_GLOBAL_MIN_ID_RECORD_DESC
  WORLD_RECORD_GLOBAL_MAX_ID_LEVEL_ASC
  WORLD_RECORD_GLOBAL_MAX_ID_LEVEL_DESC
  WORLD_RECORD_GLOBAL_MIN_ID_LEVEL_ASC
  WORLD_RECORD_GLOBAL_MIN_ID_LEVEL_DESC
  WORLD_RECORD_GLOBAL_MAX_DATE_CREATED_ASC
  WORLD_RECORD_GLOBAL_MAX_DATE_CREATED_DESC
  WORLD_RECORD_GLOBAL_MIN_DATE_CREATED_ASC
  WORLD_RECORD_GLOBAL_MIN_DATE_CREATED_DESC
  WORLD_RECORD_GLOBAL_MAX_DATE_UPDATED_ASC
  WORLD_RECORD_GLOBAL_MAX_DATE_UPDATED_DESC
  WORLD_RECORD_GLOBAL_MIN_DATE_UPDATED_ASC
  WORLD_RECORD_GLOBAL_MIN_DATE_UPDATED_DESC
  WORLD_RECORD_GLOBAL_MAX_ID_USER_ASC
  WORLD_RECORD_GLOBAL_MAX_ID_USER_DESC
  WORLD_RECORD_GLOBAL_MIN_ID_USER_ASC
  WORLD_RECORD_GLOBAL_MIN_ID_USER_DESC
}

"A condition to be used against `Record` object types. All fields are tested for equality and combined with a logical ‘and.’"
input RecordCondition {
  "Checks for equality with the object’s `id` field."
  id: Int
  "Checks for equality with the object’s `userId` field."
  userId: Int
  "Checks for equality with the object’s `time` field."
  time: Float
  "Checks for equality with the object’s `gameVersion` field."
  gameVersion: String
  "Checks for equality with the object’s `levelId` field."
  levelId: Int
  "Checks for equality with the object’s `modVersion` field."
  modVersion: String
  "Checks for equality with the object’s `dateCreated` field."
  dateCreated: Datetime
  "Checks for equality with the object’s `dateUpdated` field."
  dateUpdated: Datetime
  "Checks for equality with the object’s `splits` field."
  splits: [Float]
  "Checks for equality with the object’s `speeds` field."
  speeds: [Float]
}

"A connection to a list of `WorldRecordGlobal` values."
type WorldRecordGlobalsConnection {
  "A list of `WorldRecordGlobal` objects."
  nodes: [WorldRecordGlobal!]!
  "A list of edges which contains the `WorldRecordGlobal` and cursor to aid in pagination."
  edges: [WorldRecordGlobalsEdge!]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `WorldRecordGlobal` you could get from the connection."
  totalCount: Int!
}

type WorldRecordGlobal implements Node {
  "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
  nodeId: ID!
  id: Int!
  recordId: Int!
  levelId: Int!
  dateCreated: Datetime!
  dateUpdated: Datetime
  userId: Int!
  "Reads a single `Record` that is related to this `WorldRecordGlobal`."
  record: Record
  "Reads a single `Level` that is related to this `WorldRecordGlobal`."
  level: Level
  "Reads a single `User` that is related to this `WorldRecordGlobal`."
  user: User
}

"A `WorldRecordGlobal` edge in the connection."
type WorldRecordGlobalsEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `WorldRecordGlobal` at the end of the edge."
  node: WorldRecordGlobal!
}

"Methods to use when ordering `WorldRecordGlobal`."
enum WorldRecordGlobalsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  ID_RECORD_ASC
  ID_RECORD_DESC
  ID_LEVEL_ASC
  ID_LEVEL_DESC
  DATE_CREATED_ASC
  DATE_CREATED_DESC
  DATE_UPDATED_ASC
  DATE_UPDATED_DESC
  ID_USER_ASC
  ID_USER_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  RECORD_ID_ASC
  RECORD_ID_DESC
  RECORD_ID_USER_ASC
  RECORD_ID_USER_DESC
  RECORD_TIME_ASC
  RECORD_TIME_DESC
  RECORD_GAME_VERSION_ASC
  RECORD_GAME_VERSION_DESC
  RECORD_ID_LEVEL_ASC
  RECORD_ID_LEVEL_DESC
  RECORD_MOD_VERSION_ASC
  RECORD_MOD_VERSION_DESC
  RECORD_DATE_CREATED_ASC
  RECORD_DATE_CREATED_DESC
  RECORD_DATE_UPDATED_ASC
  RECORD_DATE_UPDATED_DESC
  RECORD_SPLITS_ASC
  RECORD_SPLITS_DESC
  RECORD_SPEEDS_ASC
  RECORD_SPEEDS_DESC
  LEVEL_ID_ASC
  LEVEL_ID_DESC
  LEVEL_HASH_ASC
  LEVEL_HASH_DESC
  LEVEL_DATE_CREATED_ASC
  LEVEL_DATE_CREATED_DESC
  LEVEL_DATE_UPDATED_ASC
  LEVEL_DATE_UPDATED_DESC
  USER_ID_ASC
  USER_ID_DESC
  USER_STEAM_NAME_ASC
  USER_STEAM_NAME_DESC
  USER_BANNED_ASC
  USER_BANNED_DESC
  USER_DATE_CREATED_ASC
  USER_DATE_CREATED_DESC
  USER_DATE_UPDATED_ASC
  USER_DATE_UPDATED_DESC
  USER_STEAM_ID_ASC
  USER_STEAM_ID_DESC
  USER_DISCORD_ID_ASC
  USER_DISCORD_ID_DESC
}

"A condition to be used against `WorldRecordGlobal` object types. All fields are\ntested for equality and combined with a logical ‘and.’"
input WorldRecordGlobalCondition {
  "Checks for equality with the object’s `id` field."
  id: Int
  "Checks for equality with the object’s `recordId` field."
  recordId: Int
  "Checks for equality with the object’s `levelId` field."
  levelId: Int
  "Checks for equality with the object’s `dateCreated` field."
  dateCreated: Datetime
  "Checks for equality with the object’s `dateUpdated` field."
  dateUpdated: Datetime
  "Checks for equality with the object’s `userId` field."
  userId: Int
}

"A connection to a list of `Vote` values."
type VotesConnection {
  "A list of `Vote` objects."
  nodes: [Vote!]!
  "A list of edges which contains the `Vote` and cursor to aid in pagination."
  edges: [VotesEdge!]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `Vote` you could get from the connection."
  totalCount: Int!
}

type Vote implements Node {
  "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
  nodeId: ID!
  id: Int!
  userId: Int!
  levelId: Int!
  value: Int!
  dateCreated: Datetime!
  dateUpdated: Datetime
  "Reads a single `User` that is related to this `Vote`."
  user: User
  "Reads a single `Level` that is related to this `Vote`."
  level: Level
}

"A `Vote` edge in the connection."
type VotesEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `Vote` at the end of the edge."
  node: Vote!
}

"Methods to use when ordering `Vote`."
enum VotesOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  ID_USER_ASC
  ID_USER_DESC
  ID_LEVEL_ASC
  ID_LEVEL_DESC
  VALUE_ASC
  VALUE_DESC
  DATE_CREATED_ASC
  DATE_CREATED_DESC
  DATE_UPDATED_ASC
  DATE_UPDATED_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  USER_ID_ASC
  USER_ID_DESC
  USER_STEAM_NAME_ASC
  USER_STEAM_NAME_DESC
  USER_BANNED_ASC
  USER_BANNED_DESC
  USER_DATE_CREATED_ASC
  USER_DATE_CREATED_DESC
  USER_DATE_UPDATED_ASC
  USER_DATE_UPDATED_DESC
  USER_STEAM_ID_ASC
  USER_STEAM_ID_DESC
  USER_DISCORD_ID_ASC
  USER_DISCORD_ID_DESC
  LEVEL_ID_ASC
  LEVEL_ID_DESC
  LEVEL_HASH_ASC
  LEVEL_HASH_DESC
  LEVEL_DATE_CREATED_ASC
  LEVEL_DATE_CREATED_DESC
  LEVEL_DATE_UPDATED_ASC
  LEVEL_DATE_UPDATED_DESC
}

"A condition to be used against `Vote` object types. All fields are tested for equality and combined with a logical ‘and.’"
input VoteCondition {
  "Checks for equality with the object’s `id` field."
  id: Int
  "Checks for equality with the object’s `userId` field."
  userId: Int
  "Checks for equality with the object’s `levelId` field."
  levelId: Int
  "Checks for equality with the object’s `value` field."
  value: Int
  "Checks for equality with the object’s `dateCreated` field."
  dateCreated: Datetime
  "Checks for equality with the object’s `dateUpdated` field."
  dateUpdated: Datetime
}

"A connection to a list of `LevelPointsHistory` values."
type LevelPointsHistoriesConnection {
  "A list of `LevelPointsHistory` objects."
  nodes: [LevelPointsHistory!]!
  "A list of edges which contains the `LevelPointsHistory` and cursor to aid in pagination."
  edges: [LevelPointsHistoriesEdge!]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `LevelPointsHistory` you could get from the connection."
  totalCount: Int!
}

type LevelPointsHistory implements Node {
  "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
  nodeId: ID!
  id: Int!
  levelId: Int!
  points: Int!
  dateCreated: Datetime!
  "Reads a single `Level` that is related to this `LevelPointsHistory`."
  level: Level
}

"A `LevelPointsHistory` edge in the connection."
type LevelPointsHistoriesEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `LevelPointsHistory` at the end of the edge."
  node: LevelPointsHistory!
}

"Methods to use when ordering `LevelPointsHistory`."
enum LevelPointsHistoriesOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  ID_LEVEL_ASC
  ID_LEVEL_DESC
  POINTS_ASC
  POINTS_DESC
  DATE_CREATED_ASC
  DATE_CREATED_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  LEVEL_ID_ASC
  LEVEL_ID_DESC
  LEVEL_HASH_ASC
  LEVEL_HASH_DESC
  LEVEL_DATE_CREATED_ASC
  LEVEL_DATE_CREATED_DESC
  LEVEL_DATE_UPDATED_ASC
  LEVEL_DATE_UPDATED_DESC
}

"A condition to be used against `LevelPointsHistory` object types. All fields are\ntested for equality and combined with a logical ‘and.’"
input LevelPointsHistoryCondition {
  "Checks for equality with the object’s `id` field."
  id: Int
  "Checks for equality with the object’s `levelId` field."
  levelId: Int
  "Checks for equality with the object’s `points` field."
  points: Int
  "Checks for equality with the object’s `dateCreated` field."
  dateCreated: Datetime
}

"A connection to a list of `User` values, with data from `Favourite`."
type LevelUsersByFavouriteManyToManyConnection {
  "A list of `User` objects."
  nodes: [User!]!
  "A list of edges which contains the `User`, info from the `Favourite`, and the cursor to aid in pagination."
  edges: [LevelUsersByFavouriteManyToManyEdge!]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `User` you could get from the connection."
  totalCount: Int!
}

"A `User` edge in the connection, with data from `Favourite`."
type LevelUsersByFavouriteManyToManyEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `User` at the end of the edge."
  node: User!
  "Reads and enables pagination through a set of `Favourite`."
  favourites("Only read the first `n` values of the set." first: Int "Only read the last `n` values of the set." last: Int "Skip the first `n` values from our `after` cursor, an alternative to cursor\nbased pagination. May not be used with `last`." offset: Int "Read all values in the set before (above) this cursor." before: Cursor "Read all values in the set after (below) this cursor." after: Cursor "The method to use when ordering `Favourite`." orderBy: [FavouritesOrderBy!] = [ PRIMARY_KEY_ASC ] "A condition to be used in determining which values should be returned by the collection." condition: FavouriteCondition "A filter to be used in determining which values should be returned by the collection." filter: FavouriteFilter): FavouritesConnection!
}

"Methods to use when ordering `User`."
enum UsersOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  STEAM_NAME_ASC
  STEAM_NAME_DESC
  BANNED_ASC
  BANNED_DESC
  DATE_CREATED_ASC
  DATE_CREATED_DESC
  DATE_UPDATED_ASC
  DATE_UPDATED_DESC
  STEAM_ID_ASC
  STEAM_ID_DESC
  DISCORD_ID_ASC
  DISCORD_ID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  FAVOURITE_COUNT_ASC
  FAVOURITE_COUNT_DESC
  FAVOURITE_MAX_ID_ASC
  FAVOURITE_MAX_ID_DESC
  FAVOURITE_MIN_ID_ASC
  FAVOURITE_MIN_ID_DESC
  FAVOURITE_MAX_ID_USER_ASC
  FAVOURITE_MAX_ID_USER_DESC
  FAVOURITE_MIN_ID_USER_ASC
  FAVOURITE_MIN_ID_USER_DESC
  FAVOURITE_MAX_DATE_CREATED_ASC
  FAVOURITE_MAX_DATE_CREATED_DESC
  FAVOURITE_MIN_DATE_CREATED_ASC
  FAVOURITE_MIN_DATE_CREATED_DESC
  FAVOURITE_MAX_DATE_UPDATED_ASC
  FAVOURITE_MAX_DATE_UPDATED_DESC
  FAVOURITE_MIN_DATE_UPDATED_ASC
  FAVOURITE_MIN_DATE_UPDATED_DESC
  FAVOURITE_MAX_ID_LEVEL_ASC
  FAVOURITE_MAX_ID_LEVEL_DESC
  FAVOURITE_MIN_ID_LEVEL_ASC
  FAVOURITE_MIN_ID_LEVEL_DESC
  PERSONAL_BEST_GLOBAL_COUNT_ASC
  PERSONAL_BEST_GLOBAL_COUNT_DESC
  PERSONAL_BEST_GLOBAL_MAX_ID_ASC
  PERSONAL_BEST_GLOBAL_MAX_ID_DESC
  PERSONAL_BEST_GLOBAL_MIN_ID_ASC
  PERSONAL_BEST_GLOBAL_MIN_ID_DESC
  PERSONAL_BEST_GLOBAL_MAX_ID_RECORD_ASC
  PERSONAL_BEST_GLOBAL_MAX_ID_RECORD_DESC
  PERSONAL_BEST_GLOBAL_MIN_ID_RECORD_ASC
  PERSONAL_BEST_GLOBAL_MIN_ID_RECORD_DESC
  PERSONAL_BEST_GLOBAL_MAX_ID_USER_ASC
  PERSONAL_BEST_GLOBAL_MAX_ID_USER_DESC
  PERSONAL_BEST_GLOBAL_MIN_ID_USER_ASC
  PERSONAL_BEST_GLOBAL_MIN_ID_USER_DESC
  PERSONAL_BEST_GLOBAL_MAX_ID_LEVEL_ASC
  PERSONAL_BEST_GLOBAL_MAX_ID_LEVEL_DESC
  PERSONAL_BEST_GLOBAL_MIN_ID_LEVEL_ASC
  PERSONAL_BEST_GLOBAL_MIN_ID_LEVEL_DESC
  PERSONAL_BEST_GLOBAL_MAX_DATE_CREATED_ASC
  PERSONAL_BEST_GLOBAL_MAX_DATE_CREATED_DESC
  PERSONAL_BEST_GLOBAL_MIN_DATE_CREATED_ASC
  PERSONAL_BEST_GLOBAL_MIN_DATE_CREATED_DESC
  PERSONAL_BEST_GLOBAL_MAX_DATE_UPDATED_ASC
  PERSONAL_BEST_GLOBAL_MAX_DATE_UPDATED_DESC
  PERSONAL_BEST_GLOBAL_MIN_DATE_UPDATED_ASC
  PERSONAL_BEST_GLOBAL_MIN_DATE_UPDATED_DESC
  USER_POINT_COUNT_ASC
  USER_POINT_COUNT_DESC
  USER_POINT_MAX_ID_ASC
  USER_POINT_MAX_ID_DESC
  USER_POINT_MIN_ID_ASC
  USER_POINT_MIN_ID_DESC
  USER_POINT_MAX_ID_USER_ASC
  USER_POINT_MAX_ID_USER_DESC
  USER_POINT_MIN_ID_USER_ASC
  USER_POINT_MIN_ID_USER_DESC
  USER_POINT_MAX_POINTS_ASC
  USER_POINT_MAX_POINTS_DESC
  USER_POINT_MIN_POINTS_ASC
  USER_POINT_MIN_POINTS_DESC
  USER_POINT_MAX_DATE_CREATED_ASC
  USER_POINT_MAX_DATE_CREATED_DESC
  USER_POINT_MIN_DATE_CREATED_ASC
  USER_POINT_MIN_DATE_CREATED_DESC
  USER_POINT_MAX_DATE_UPDATED_ASC
  USER_POINT_MAX_DATE_UPDATED_DESC
  USER_POINT_MIN_DATE_UPDATED_ASC
  USER_POINT_MIN_DATE_UPDATED_DESC
  USER_POINT_MAX_RANK_ASC
  USER_POINT_MAX_RANK_DESC
  USER_POINT_MIN_RANK_ASC
  USER_POINT_MIN_RANK_DESC
  USER_POINT_MAX_WORLD_RECORDS_ASC
  USER_POINT_MAX_WORLD_RECORDS_DESC
  USER_POINT_MIN_WORLD_RECORDS_ASC
  USER_POINT_MIN_WORLD_RECORDS_DESC
  USER_POINT_MAX_TOTAL_POINTS_ASC
  USER_POINT_MAX_TOTAL_POINTS_DESC
  USER_POINT_MIN_TOTAL_POINTS_ASC
  USER_POINT_MIN_TOTAL_POINTS_DESC
  RECORD_COUNT_ASC
  RECORD_COUNT_DESC
  RECORD_MAX_ID_ASC
  RECORD_MAX_ID_DESC
  RECORD_MIN_ID_ASC
  RECORD_MIN_ID_DESC
  RECORD_MAX_ID_USER_ASC
  RECORD_MAX_ID_USER_DESC
  RECORD_MIN_ID_USER_ASC
  RECORD_MIN_ID_USER_DESC
  RECORD_MAX_TIME_ASC
  RECORD_MAX_TIME_DESC
  RECORD_MIN_TIME_ASC
  RECORD_MIN_TIME_DESC
  RECORD_MAX_GAME_VERSION_ASC
  RECORD_MAX_GAME_VERSION_DESC
  RECORD_MIN_GAME_VERSION_ASC
  RECORD_MIN_GAME_VERSION_DESC
  RECORD_MAX_ID_LEVEL_ASC
  RECORD_MAX_ID_LEVEL_DESC
  RECORD_MIN_ID_LEVEL_ASC
  RECORD_MIN_ID_LEVEL_DESC
  RECORD_MAX_MOD_VERSION_ASC
  RECORD_MAX_MOD_VERSION_DESC
  RECORD_MIN_MOD_VERSION_ASC
  RECORD_MIN_MOD_VERSION_DESC
  RECORD_MAX_DATE_CREATED_ASC
  RECORD_MAX_DATE_CREATED_DESC
  RECORD_MIN_DATE_CREATED_ASC
  RECORD_MIN_DATE_CREATED_DESC
  RECORD_MAX_DATE_UPDATED_ASC
  RECORD_MAX_DATE_UPDATED_DESC
  RECORD_MIN_DATE_UPDATED_ASC
  RECORD_MIN_DATE_UPDATED_DESC
  RECORD_MAX_SPLITS_ASC
  RECORD_MAX_SPLITS_DESC
  RECORD_MIN_SPLITS_ASC
  RECORD_MIN_SPLITS_DESC
  RECORD_MAX_SPEEDS_ASC
  RECORD_MAX_SPEEDS_DESC
  RECORD_MIN_SPEEDS_ASC
  RECORD_MIN_SPEEDS_DESC
  WORLD_RECORD_GLOBAL_COUNT_ASC
  WORLD_RECORD_GLOBAL_COUNT_DESC
  WORLD_RECORD_GLOBAL_MAX_ID_ASC
  WORLD_RECORD_GLOBAL_MAX_ID_DESC
  WORLD_RECORD_GLOBAL_MIN_ID_ASC
  WORLD_RECORD_GLOBAL_MIN_ID_DESC
  WORLD_RECORD_GLOBAL_MAX_ID_RECORD_ASC
  WORLD_RECORD_GLOBAL_MAX_ID_RECORD_DESC
  WORLD_RECORD_GLOBAL_MIN_ID_RECORD_ASC
  WORLD_RECORD_GLOBAL_MIN_ID_RECORD_DESC
  WORLD_RECORD_GLOBAL_MAX_ID_LEVEL_ASC
  WORLD_RECORD_GLOBAL_MAX_ID_LEVEL_DESC
  WORLD_RECORD_GLOBAL_MIN_ID_LEVEL_ASC
  WORLD_RECORD_GLOBAL_MIN_ID_LEVEL_DESC
  WORLD_RECORD_GLOBAL_MAX_DATE_CREATED_ASC
  WORLD_RECORD_GLOBAL_MAX_DATE_CREATED_DESC
  WORLD_RECORD_GLOBAL_MIN_DATE_CREATED_ASC
  WORLD_RECORD_GLOBAL_MIN_DATE_CREATED_DESC
  WORLD_RECORD_GLOBAL_MAX_DATE_UPDATED_ASC
  WORLD_RECORD_GLOBAL_MAX_DATE_UPDATED_DESC
  WORLD_RECORD_GLOBAL_MIN_DATE_UPDATED_ASC
  WORLD_RECORD_GLOBAL_MIN_DATE_UPDATED_DESC
  WORLD_RECORD_GLOBAL_MAX_ID_USER_ASC
  WORLD_RECORD_GLOBAL_MAX_ID_USER_DESC
  WORLD_RECORD_GLOBAL_MIN_ID_USER_ASC
  WORLD_RECORD_GLOBAL_MIN_ID_USER_DESC
  VOTE_COUNT_ASC
  VOTE_COUNT_DESC
  VOTE_MAX_ID_ASC
  VOTE_MAX_ID_DESC
  VOTE_MIN_ID_ASC
  VOTE_MIN_ID_DESC
  VOTE_MAX_ID_USER_ASC
  VOTE_MAX_ID_USER_DESC
  VOTE_MIN_ID_USER_ASC
  VOTE_MIN_ID_USER_DESC
  VOTE_MAX_ID_LEVEL_ASC
  VOTE_MAX_ID_LEVEL_DESC
  VOTE_MIN_ID_LEVEL_ASC
  VOTE_MIN_ID_LEVEL_DESC
  VOTE_MAX_VALUE_ASC
  VOTE_MAX_VALUE_DESC
  VOTE_MIN_VALUE_ASC
  VOTE_MIN_VALUE_DESC
  VOTE_MAX_DATE_CREATED_ASC
  VOTE_MAX_DATE_CREATED_DESC
  VOTE_MIN_DATE_CREATED_ASC
  VOTE_MIN_DATE_CREATED_DESC
  VOTE_MAX_DATE_UPDATED_ASC
  VOTE_MAX_DATE_UPDATED_DESC
  VOTE_MIN_DATE_UPDATED_ASC
  VOTE_MIN_DATE_UPDATED_DESC
  USER_POINTS_HISTORY_COUNT_ASC
  USER_POINTS_HISTORY_COUNT_DESC
  USER_POINTS_HISTORY_MAX_ID_ASC
  USER_POINTS_HISTORY_MAX_ID_DESC
  USER_POINTS_HISTORY_MIN_ID_ASC
  USER_POINTS_HISTORY_MIN_ID_DESC
  USER_POINTS_HISTORY_MAX_ID_USER_ASC
  USER_POINTS_HISTORY_MAX_ID_USER_DESC
  USER_POINTS_HISTORY_MIN_ID_USER_ASC
  USER_POINTS_HISTORY_MIN_ID_USER_DESC
  USER_POINTS_HISTORY_MAX_POINTS_ASC
  USER_POINTS_HISTORY_MAX_POINTS_DESC
  USER_POINTS_HISTORY_MIN_POINTS_ASC
  USER_POINTS_HISTORY_MIN_POINTS_DESC
  USER_POINTS_HISTORY_MAX_TOTAL_POINTS_ASC
  USER_POINTS_HISTORY_MAX_TOTAL_POINTS_DESC
  USER_POINTS_HISTORY_MIN_TOTAL_POINTS_ASC
  USER_POINTS_HISTORY_MIN_TOTAL_POINTS_DESC
  USER_POINTS_HISTORY_MAX_RANK_ASC
  USER_POINTS_HISTORY_MAX_RANK_DESC
  USER_POINTS_HISTORY_MIN_RANK_ASC
  USER_POINTS_HISTORY_MIN_RANK_DESC
  USER_POINTS_HISTORY_MAX_WORLD_RECORDS_ASC
  USER_POINTS_HISTORY_MAX_WORLD_RECORDS_DESC
  USER_POINTS_HISTORY_MIN_WORLD_RECORDS_ASC
  USER_POINTS_HISTORY_MIN_WORLD_RECORDS_DESC
  USER_POINTS_HISTORY_MAX_DATE_CREATED_ASC
  USER_POINTS_HISTORY_MAX_DATE_CREATED_DESC
  USER_POINTS_HISTORY_MIN_DATE_CREATED_ASC
  USER_POINTS_HISTORY_MIN_DATE_CREATED_DESC
}

"A condition to be used against `User` object types. All fields are tested for equality and combined with a logical ‘and.’"
input UserCondition {
  "Checks for equality with the object’s `id` field."
  id: Int
  "Checks for equality with the object’s `steamName` field."
  steamName: String
  "Checks for equality with the object’s `banned` field."
  banned: Boolean
  "Checks for equality with the object’s `dateCreated` field."
  dateCreated: Datetime
  "Checks for equality with the object’s `dateUpdated` field."
  dateUpdated: Datetime
  "Checks for equality with the object’s `steamId` field."
  steamId: BigInt
  "Checks for equality with the object’s `discordId` field."
  discordId: BigInt
}

"A connection to a list of `Record` values, with data from `PersonalBestGlobal`."
type LevelRecordsByPersonalBestGlobalManyToManyConnection {
  "A list of `Record` objects."
  nodes: [Record!]!
  "A list of edges which contains the `Record`, info from the `PersonalBestGlobal`, and the cursor to aid in pagination."
  edges: [LevelRecordsByPersonalBestGlobalManyToManyEdge!]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `Record` you could get from the connection."
  totalCount: Int!
}

"A `Record` edge in the connection, with data from `PersonalBestGlobal`."
type LevelRecordsByPersonalBestGlobalManyToManyEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `Record` at the end of the edge."
  node: Record!
  "Reads and enables pagination through a set of `PersonalBestGlobal`."
  personalBestGlobals("Only read the first `n` values of the set." first: Int "Only read the last `n` values of the set." last: Int "Skip the first `n` values from our `after` cursor, an alternative to cursor\nbased pagination. May not be used with `last`." offset: Int "Read all values in the set before (above) this cursor." before: Cursor "Read all values in the set after (below) this cursor." after: Cursor "The method to use when ordering `PersonalBestGlobal`." orderBy: [PersonalBestGlobalsOrderBy!] = [ PRIMARY_KEY_ASC ] "A condition to be used in determining which values should be returned by the collection." condition: PersonalBestGlobalCondition "A filter to be used in determining which values should be returned by the collection." filter: PersonalBestGlobalFilter): PersonalBestGlobalsConnection!
}

"A connection to a list of `User` values, with data from `PersonalBestGlobal`."
type LevelUsersByPersonalBestGlobalManyToManyConnection {
  "A list of `User` objects."
  nodes: [User!]!
  "A list of edges which contains the `User`, info from the `PersonalBestGlobal`, and the cursor to aid in pagination."
  edges: [LevelUsersByPersonalBestGlobalManyToManyEdge!]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `User` you could get from the connection."
  totalCount: Int!
}

"A `User` edge in the connection, with data from `PersonalBestGlobal`."
type LevelUsersByPersonalBestGlobalManyToManyEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `User` at the end of the edge."
  node: User!
  "Reads and enables pagination through a set of `PersonalBestGlobal`."
  personalBestGlobals("Only read the first `n` values of the set." first: Int "Only read the last `n` values of the set." last: Int "Skip the first `n` values from our `after` cursor, an alternative to cursor\nbased pagination. May not be used with `last`." offset: Int "Read all values in the set before (above) this cursor." before: Cursor "Read all values in the set after (below) this cursor." after: Cursor "The method to use when ordering `PersonalBestGlobal`." orderBy: [PersonalBestGlobalsOrderBy!] = [ PRIMARY_KEY_ASC ] "A condition to be used in determining which values should be returned by the collection." condition: PersonalBestGlobalCondition "A filter to be used in determining which values should be returned by the collection." filter: PersonalBestGlobalFilter): PersonalBestGlobalsConnection!
}

"A connection to a list of `User` values, with data from `Record`."
type LevelUsersByRecordManyToManyConnection {
  "A list of `User` objects."
  nodes: [User!]!
  "A list of edges which contains the `User`, info from the `Record`, and the cursor to aid in pagination."
  edges: [LevelUsersByRecordManyToManyEdge!]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `User` you could get from the connection."
  totalCount: Int!
}

"A `User` edge in the connection, with data from `Record`."
type LevelUsersByRecordManyToManyEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `User` at the end of the edge."
  node: User!
  "Reads and enables pagination through a set of `Record`."
  records("Only read the first `n` values of the set." first: Int "Only read the last `n` values of the set." last: Int "Skip the first `n` values from our `after` cursor, an alternative to cursor\nbased pagination. May not be used with `last`." offset: Int "Read all values in the set before (above) this cursor." before: Cursor "Read all values in the set after (below) this cursor." after: Cursor "The method to use when ordering `Record`." orderBy: [RecordsOrderBy!] = [ PRIMARY_KEY_ASC ] "A condition to be used in determining which values should be returned by the collection." condition: RecordCondition "A filter to be used in determining which values should be returned by the collection." filter: RecordFilter): RecordsConnection!
}

"A connection to a list of `Record` values, with data from `WorldRecordGlobal`."
type LevelRecordsByWorldRecordGlobalManyToManyConnection {
  "A list of `Record` objects."
  nodes: [Record!]!
  "A list of edges which contains the `Record`, info from the `WorldRecordGlobal`, and the cursor to aid in pagination."
  edges: [LevelRecordsByWorldRecordGlobalManyToManyEdge!]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `Record` you could get from the connection."
  totalCount: Int!
}

"A `Record` edge in the connection, with data from `WorldRecordGlobal`."
type LevelRecordsByWorldRecordGlobalManyToManyEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `Record` at the end of the edge."
  node: Record!
  "Reads and enables pagination through a set of `WorldRecordGlobal`."
  worldRecordGlobals("Only read the first `n` values of the set." first: Int "Only read the last `n` values of the set." last: Int "Skip the first `n` values from our `after` cursor, an alternative to cursor\nbased pagination. May not be used with `last`." offset: Int "Read all values in the set before (above) this cursor." before: Cursor "Read all values in the set after (below) this cursor." after: Cursor "The method to use when ordering `WorldRecordGlobal`." orderBy: [WorldRecordGlobalsOrderBy!] = [ PRIMARY_KEY_ASC ] "A condition to be used in determining which values should be returned by the collection." condition: WorldRecordGlobalCondition "A filter to be used in determining which values should be returned by the collection." filter: WorldRecordGlobalFilter): WorldRecordGlobalsConnection!
}

"A connection to a list of `User` values, with data from `WorldRecordGlobal`."
type LevelUsersByWorldRecordGlobalManyToManyConnection {
  "A list of `User` objects."
  nodes: [User!]!
  "A list of edges which contains the `User`, info from the `WorldRecordGlobal`, and the cursor to aid in pagination."
  edges: [LevelUsersByWorldRecordGlobalManyToManyEdge!]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `User` you could get from the connection."
  totalCount: Int!
}

"A `User` edge in the connection, with data from `WorldRecordGlobal`."
type LevelUsersByWorldRecordGlobalManyToManyEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `User` at the end of the edge."
  node: User!
  "Reads and enables pagination through a set of `WorldRecordGlobal`."
  worldRecordGlobals("Only read the first `n` values of the set." first: Int "Only read the last `n` values of the set." last: Int "Skip the first `n` values from our `after` cursor, an alternative to cursor\nbased pagination. May not be used with `last`." offset: Int "Read all values in the set before (above) this cursor." before: Cursor "Read all values in the set after (below) this cursor." after: Cursor "The method to use when ordering `WorldRecordGlobal`." orderBy: [WorldRecordGlobalsOrderBy!] = [ PRIMARY_KEY_ASC ] "A condition to be used in determining which values should be returned by the collection." condition: WorldRecordGlobalCondition "A filter to be used in determining which values should be returned by the collection." filter: WorldRecordGlobalFilter): WorldRecordGlobalsConnection!
}

"A connection to a list of `User` values, with data from `Vote`."
type LevelUsersByVoteManyToManyConnection {
  "A list of `User` objects."
  nodes: [User!]!
  "A list of edges which contains the `User`, info from the `Vote`, and the cursor to aid in pagination."
  edges: [LevelUsersByVoteManyToManyEdge!]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `User` you could get from the connection."
  totalCount: Int!
}

"A `User` edge in the connection, with data from `Vote`."
type LevelUsersByVoteManyToManyEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `User` at the end of the edge."
  node: User!
  "Reads and enables pagination through a set of `Vote`."
  votes("Only read the first `n` values of the set." first: Int "Only read the last `n` values of the set." last: Int "Skip the first `n` values from our `after` cursor, an alternative to cursor\nbased pagination. May not be used with `last`." offset: Int "Read all values in the set before (above) this cursor." before: Cursor "Read all values in the set after (below) this cursor." after: Cursor "The method to use when ordering `Vote`." orderBy: [VotesOrderBy!] = [ PRIMARY_KEY_ASC ] "A condition to be used in determining which values should be returned by the collection." condition: VoteCondition "A filter to be used in determining which values should be returned by the collection." filter: VoteFilter): VotesConnection!
}

type RecordMedia implements Node {
  "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
  nodeId: ID!
  id: Int!
  recordId: Int!
  ghostUrl: String
  dateCreated: Datetime!
  dateUpdated: Datetime
  "Reads a single `Record` that is related to this `RecordMedia`."
  record: Record
}

"A connection to a list of `RecordMedia` values."
type RecordMediaConnection {
  "A list of `RecordMedia` objects."
  nodes: [RecordMedia!]!
  "A list of edges which contains the `RecordMedia` and cursor to aid in pagination."
  edges: [RecordMediaEdge!]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `RecordMedia` you could get from the connection."
  totalCount: Int!
}

"A `RecordMedia` edge in the connection."
type RecordMediaEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `RecordMedia` at the end of the edge."
  node: RecordMedia!
}

"Methods to use when ordering `RecordMedia`."
enum RecordMediaOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  ID_RECORD_ASC
  ID_RECORD_DESC
  GHOST_URL_ASC
  GHOST_URL_DESC
  DATE_CREATED_ASC
  DATE_CREATED_DESC
  DATE_UPDATED_ASC
  DATE_UPDATED_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  RECORD_ID_ASC
  RECORD_ID_DESC
  RECORD_ID_USER_ASC
  RECORD_ID_USER_DESC
  RECORD_TIME_ASC
  RECORD_TIME_DESC
  RECORD_GAME_VERSION_ASC
  RECORD_GAME_VERSION_DESC
  RECORD_ID_LEVEL_ASC
  RECORD_ID_LEVEL_DESC
  RECORD_MOD_VERSION_ASC
  RECORD_MOD_VERSION_DESC
  RECORD_DATE_CREATED_ASC
  RECORD_DATE_CREATED_DESC
  RECORD_DATE_UPDATED_ASC
  RECORD_DATE_UPDATED_DESC
  RECORD_SPLITS_ASC
  RECORD_SPLITS_DESC
  RECORD_SPEEDS_ASC
  RECORD_SPEEDS_DESC
}

"A condition to be used against `RecordMedia` object types. All fields are tested\nfor equality and combined with a logical ‘and.’"
input RecordMediaCondition {
  "Checks for equality with the object’s `id` field."
  id: Int
  "Checks for equality with the object’s `recordId` field."
  recordId: Int
  "Checks for equality with the object’s `ghostUrl` field."
  ghostUrl: String
  "Checks for equality with the object’s `dateCreated` field."
  dateCreated: Datetime
  "Checks for equality with the object’s `dateUpdated` field."
  dateUpdated: Datetime
}

"A connection to a list of `User` values, with data from `PersonalBestGlobal`."
type RecordUsersByPersonalBestGlobalManyToManyConnection {
  "A list of `User` objects."
  nodes: [User!]!
  "A list of edges which contains the `User`, info from the `PersonalBestGlobal`, and the cursor to aid in pagination."
  edges: [RecordUsersByPersonalBestGlobalManyToManyEdge!]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `User` you could get from the connection."
  totalCount: Int!
}

"A `User` edge in the connection, with data from `PersonalBestGlobal`."
type RecordUsersByPersonalBestGlobalManyToManyEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `User` at the end of the edge."
  node: User!
  "Reads and enables pagination through a set of `PersonalBestGlobal`."
  personalBestGlobals("Only read the first `n` values of the set." first: Int "Only read the last `n` values of the set." last: Int "Skip the first `n` values from our `after` cursor, an alternative to cursor\nbased pagination. May not be used with `last`." offset: Int "Read all values in the set before (above) this cursor." before: Cursor "Read all values in the set after (below) this cursor." after: Cursor "The method to use when ordering `PersonalBestGlobal`." orderBy: [PersonalBestGlobalsOrderBy!] = [ PRIMARY_KEY_ASC ] "A condition to be used in determining which values should be returned by the collection." condition: PersonalBestGlobalCondition "A filter to be used in determining which values should be returned by the collection." filter: PersonalBestGlobalFilter): PersonalBestGlobalsConnection!
}

"A connection to a list of `Level` values, with data from `PersonalBestGlobal`."
type RecordLevelsByPersonalBestGlobalManyToManyConnection {
  "A list of `Level` objects."
  nodes: [Level!]!
  "A list of edges which contains the `Level`, info from the `PersonalBestGlobal`, and the cursor to aid in pagination."
  edges: [RecordLevelsByPersonalBestGlobalManyToManyEdge!]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `Level` you could get from the connection."
  totalCount: Int!
}

"A `Level` edge in the connection, with data from `PersonalBestGlobal`."
type RecordLevelsByPersonalBestGlobalManyToManyEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `Level` at the end of the edge."
  node: Level!
  "Reads and enables pagination through a set of `PersonalBestGlobal`."
  personalBestGlobals("Only read the first `n` values of the set." first: Int "Only read the last `n` values of the set." last: Int "Skip the first `n` values from our `after` cursor, an alternative to cursor\nbased pagination. May not be used with `last`." offset: Int "Read all values in the set before (above) this cursor." before: Cursor "Read all values in the set after (below) this cursor." after: Cursor "The method to use when ordering `PersonalBestGlobal`." orderBy: [PersonalBestGlobalsOrderBy!] = [ PRIMARY_KEY_ASC ] "A condition to be used in determining which values should be returned by the collection." condition: PersonalBestGlobalCondition "A filter to be used in determining which values should be returned by the collection." filter: PersonalBestGlobalFilter): PersonalBestGlobalsConnection!
}

"Methods to use when ordering `Level`."
enum LevelsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  HASH_ASC
  HASH_DESC
  DATE_CREATED_ASC
  DATE_CREATED_DESC
  DATE_UPDATED_ASC
  DATE_UPDATED_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  FAVOURITE_COUNT_ASC
  FAVOURITE_COUNT_DESC
  FAVOURITE_MAX_ID_ASC
  FAVOURITE_MAX_ID_DESC
  FAVOURITE_MIN_ID_ASC
  FAVOURITE_MIN_ID_DESC
  FAVOURITE_MAX_ID_USER_ASC
  FAVOURITE_MAX_ID_USER_DESC
  FAVOURITE_MIN_ID_USER_ASC
  FAVOURITE_MIN_ID_USER_DESC
  FAVOURITE_MAX_DATE_CREATED_ASC
  FAVOURITE_MAX_DATE_CREATED_DESC
  FAVOURITE_MIN_DATE_CREATED_ASC
  FAVOURITE_MIN_DATE_CREATED_DESC
  FAVOURITE_MAX_DATE_UPDATED_ASC
  FAVOURITE_MAX_DATE_UPDATED_DESC
  FAVOURITE_MIN_DATE_UPDATED_ASC
  FAVOURITE_MIN_DATE_UPDATED_DESC
  FAVOURITE_MAX_ID_LEVEL_ASC
  FAVOURITE_MAX_ID_LEVEL_DESC
  FAVOURITE_MIN_ID_LEVEL_ASC
  FAVOURITE_MIN_ID_LEVEL_DESC
  LEVEL_ITEM_COUNT_ASC
  LEVEL_ITEM_COUNT_DESC
  LEVEL_ITEM_MAX_ID_ASC
  LEVEL_ITEM_MAX_ID_DESC
  LEVEL_ITEM_MIN_ID_ASC
  LEVEL_ITEM_MIN_ID_DESC
  LEVEL_ITEM_MAX_ID_LEVEL_ASC
  LEVEL_ITEM_MAX_ID_LEVEL_DESC
  LEVEL_ITEM_MIN_ID_LEVEL_ASC
  LEVEL_ITEM_MIN_ID_LEVEL_DESC
  LEVEL_ITEM_MAX_WORKSHOP_ID_ASC
  LEVEL_ITEM_MAX_WORKSHOP_ID_DESC
  LEVEL_ITEM_MIN_WORKSHOP_ID_ASC
  LEVEL_ITEM_MIN_WORKSHOP_ID_DESC
  LEVEL_ITEM_MAX_AUTHOR_ID_ASC
  LEVEL_ITEM_MAX_AUTHOR_ID_DESC
  LEVEL_ITEM_MIN_AUTHOR_ID_ASC
  LEVEL_ITEM_MIN_AUTHOR_ID_DESC
  LEVEL_ITEM_MAX_NAME_ASC
  LEVEL_ITEM_MAX_NAME_DESC
  LEVEL_ITEM_MIN_NAME_ASC
  LEVEL_ITEM_MIN_NAME_DESC
  LEVEL_ITEM_MAX_IMAGE_URL_ASC
  LEVEL_ITEM_MAX_IMAGE_URL_DESC
  LEVEL_ITEM_MIN_IMAGE_URL_ASC
  LEVEL_ITEM_MIN_IMAGE_URL_DESC
  LEVEL_ITEM_MAX_FILE_AUTHOR_ASC
  LEVEL_ITEM_MAX_FILE_AUTHOR_DESC
  LEVEL_ITEM_MIN_FILE_AUTHOR_ASC
  LEVEL_ITEM_MIN_FILE_AUTHOR_DESC
  LEVEL_ITEM_MAX_FILE_UID_ASC
  LEVEL_ITEM_MAX_FILE_UID_DESC
  LEVEL_ITEM_MIN_FILE_UID_ASC
  LEVEL_ITEM_MIN_FILE_UID_DESC
  LEVEL_ITEM_MAX_VALIDATION_TIME_AUTHOR_ASC
  LEVEL_ITEM_MAX_VALIDATION_TIME_AUTHOR_DESC
  LEVEL_ITEM_MIN_VALIDATION_TIME_AUTHOR_ASC
  LEVEL_ITEM_MIN_VALIDATION_TIME_AUTHOR_DESC
  LEVEL_ITEM_MAX_VALIDATION_TIME_GOLD_ASC
  LEVEL_ITEM_MAX_VALIDATION_TIME_GOLD_DESC
  LEVEL_ITEM_MIN_VALIDATION_TIME_GOLD_ASC
  LEVEL_ITEM_MIN_VALIDATION_TIME_GOLD_DESC
  LEVEL_ITEM_MAX_VALIDATION_TIME_SILVER_ASC
  LEVEL_ITEM_MAX_VALIDATION_TIME_SILVER_DESC
  LEVEL_ITEM_MIN_VALIDATION_TIME_SILVER_ASC
  LEVEL_ITEM_MIN_VALIDATION_TIME_SILVER_DESC
  LEVEL_ITEM_MAX_VALIDATION_TIME_BRONZE_ASC
  LEVEL_ITEM_MAX_VALIDATION_TIME_BRONZE_DESC
  LEVEL_ITEM_MIN_VALIDATION_TIME_BRONZE_ASC
  LEVEL_ITEM_MIN_VALIDATION_TIME_BRONZE_DESC
  LEVEL_ITEM_MAX_DELETED_ASC
  LEVEL_ITEM_MAX_DELETED_DESC
  LEVEL_ITEM_MIN_DELETED_ASC
  LEVEL_ITEM_MIN_DELETED_DESC
  LEVEL_ITEM_MAX_CREATED_AT_ASC
  LEVEL_ITEM_MAX_CREATED_AT_DESC
  LEVEL_ITEM_MIN_CREATED_AT_ASC
  LEVEL_ITEM_MIN_CREATED_AT_DESC
  LEVEL_ITEM_MAX_UPDATED_AT_ASC
  LEVEL_ITEM_MAX_UPDATED_AT_DESC
  LEVEL_ITEM_MIN_UPDATED_AT_ASC
  LEVEL_ITEM_MIN_UPDATED_AT_DESC
  LEVEL_ITEM_MAX_DATE_CREATED_ASC
  LEVEL_ITEM_MAX_DATE_CREATED_DESC
  LEVEL_ITEM_MIN_DATE_CREATED_ASC
  LEVEL_ITEM_MIN_DATE_CREATED_DESC
  LEVEL_ITEM_MAX_DATE_UPDATED_ASC
  LEVEL_ITEM_MAX_DATE_UPDATED_DESC
  LEVEL_ITEM_MIN_DATE_UPDATED_ASC
  LEVEL_ITEM_MIN_DATE_UPDATED_DESC
  LEVEL_METADATUM_COUNT_ASC
  LEVEL_METADATUM_COUNT_DESC
  LEVEL_METADATUM_MAX_ID_ASC
  LEVEL_METADATUM_MAX_ID_DESC
  LEVEL_METADATUM_MIN_ID_ASC
  LEVEL_METADATUM_MIN_ID_DESC
  LEVEL_METADATUM_MAX_ID_LEVEL_ASC
  LEVEL_METADATUM_MAX_ID_LEVEL_DESC
  LEVEL_METADATUM_MIN_ID_LEVEL_ASC
  LEVEL_METADATUM_MIN_ID_LEVEL_DESC
  LEVEL_METADATUM_MAX_AMOUNT_CHECKPOINTS_ASC
  LEVEL_METADATUM_MAX_AMOUNT_CHECKPOINTS_DESC
  LEVEL_METADATUM_MIN_AMOUNT_CHECKPOINTS_ASC
  LEVEL_METADATUM_MIN_AMOUNT_CHECKPOINTS_DESC
  LEVEL_METADATUM_MAX_AMOUNT_FINISHES_ASC
  LEVEL_METADATUM_MAX_AMOUNT_FINISHES_DESC
  LEVEL_METADATUM_MIN_AMOUNT_FINISHES_ASC
  LEVEL_METADATUM_MIN_AMOUNT_FINISHES_DESC
  LEVEL_METADATUM_MAX_AMOUNT_BLOCKS_ASC
  LEVEL_METADATUM_MAX_AMOUNT_BLOCKS_DESC
  LEVEL_METADATUM_MIN_AMOUNT_BLOCKS_ASC
  LEVEL_METADATUM_MIN_AMOUNT_BLOCKS_DESC
  LEVEL_METADATUM_MAX_TYPE_GROUND_ASC
  LEVEL_METADATUM_MAX_TYPE_GROUND_DESC
  LEVEL_METADATUM_MIN_TYPE_GROUND_ASC
  LEVEL_METADATUM_MIN_TYPE_GROUND_DESC
  LEVEL_METADATUM_MAX_TYPE_SKYBOX_ASC
  LEVEL_METADATUM_MAX_TYPE_SKYBOX_DESC
  LEVEL_METADATUM_MIN_TYPE_SKYBOX_ASC
  LEVEL_METADATUM_MIN_TYPE_SKYBOX_DESC
  LEVEL_METADATUM_MAX_BLOCKS_ASC
  LEVEL_METADATUM_MAX_BLOCKS_DESC
  LEVEL_METADATUM_MIN_BLOCKS_ASC
  LEVEL_METADATUM_MIN_BLOCKS_DESC
  LEVEL_METADATUM_MAX_DATE_CREATED_ASC
  LEVEL_METADATUM_MAX_DATE_CREATED_DESC
  LEVEL_METADATUM_MIN_DATE_CREATED_ASC
  LEVEL_METADATUM_MIN_DATE_CREATED_DESC
  LEVEL_METADATUM_MAX_DATE_UPDATED_ASC
  LEVEL_METADATUM_MAX_DATE_UPDATED_DESC
  LEVEL_METADATUM_MIN_DATE_UPDATED_ASC
  LEVEL_METADATUM_MIN_DATE_UPDATED_DESC
  LEVEL_POINT_COUNT_ASC
  LEVEL_POINT_COUNT_DESC
  LEVEL_POINT_MAX_ID_ASC
  LEVEL_POINT_MAX_ID_DESC
  LEVEL_POINT_MIN_ID_ASC
  LEVEL_POINT_MIN_ID_DESC
  LEVEL_POINT_MAX_POINTS_ASC
  LEVEL_POINT_MAX_POINTS_DESC
  LEVEL_POINT_MIN_POINTS_ASC
  LEVEL_POINT_MIN_POINTS_DESC
  LEVEL_POINT_MAX_ID_LEVEL_ASC
  LEVEL_POINT_MAX_ID_LEVEL_DESC
  LEVEL_POINT_MIN_ID_LEVEL_ASC
  LEVEL_POINT_MIN_ID_LEVEL_DESC
  LEVEL_POINT_MAX_DATE_CREATED_ASC
  LEVEL_POINT_MAX_DATE_CREATED_DESC
  LEVEL_POINT_MIN_DATE_CREATED_ASC
  LEVEL_POINT_MIN_DATE_CREATED_DESC
  LEVEL_POINT_MAX_DATE_UPDATED_ASC
  LEVEL_POINT_MAX_DATE_UPDATED_DESC
  LEVEL_POINT_MIN_DATE_UPDATED_ASC
  LEVEL_POINT_MIN_DATE_UPDATED_DESC
  PERSONAL_BEST_GLOBAL_COUNT_ASC
  PERSONAL_BEST_GLOBAL_COUNT_DESC
  PERSONAL_BEST_GLOBAL_MAX_ID_ASC
  PERSONAL_BEST_GLOBAL_MAX_ID_DESC
  PERSONAL_BEST_GLOBAL_MIN_ID_ASC
  PERSONAL_BEST_GLOBAL_MIN_ID_DESC
  PERSONAL_BEST_GLOBAL_MAX_ID_RECORD_ASC
  PERSONAL_BEST_GLOBAL_MAX_ID_RECORD_DESC
  PERSONAL_BEST_GLOBAL_MIN_ID_RECORD_ASC
  PERSONAL_BEST_GLOBAL_MIN_ID_RECORD_DESC
  PERSONAL_BEST_GLOBAL_MAX_ID_USER_ASC
  PERSONAL_BEST_GLOBAL_MAX_ID_USER_DESC
  PERSONAL_BEST_GLOBAL_MIN_ID_USER_ASC
  PERSONAL_BEST_GLOBAL_MIN_ID_USER_DESC
  PERSONAL_BEST_GLOBAL_MAX_ID_LEVEL_ASC
  PERSONAL_BEST_GLOBAL_MAX_ID_LEVEL_DESC
  PERSONAL_BEST_GLOBAL_MIN_ID_LEVEL_ASC
  PERSONAL_BEST_GLOBAL_MIN_ID_LEVEL_DESC
  PERSONAL_BEST_GLOBAL_MAX_DATE_CREATED_ASC
  PERSONAL_BEST_GLOBAL_MAX_DATE_CREATED_DESC
  PERSONAL_BEST_GLOBAL_MIN_DATE_CREATED_ASC
  PERSONAL_BEST_GLOBAL_MIN_DATE_CREATED_DESC
  PERSONAL_BEST_GLOBAL_MAX_DATE_UPDATED_ASC
  PERSONAL_BEST_GLOBAL_MAX_DATE_UPDATED_DESC
  PERSONAL_BEST_GLOBAL_MIN_DATE_UPDATED_ASC
  PERSONAL_BEST_GLOBAL_MIN_DATE_UPDATED_DESC
  RECORD_COUNT_ASC
  RECORD_COUNT_DESC
  RECORD_MAX_ID_ASC
  RECORD_MAX_ID_DESC
  RECORD_MIN_ID_ASC
  RECORD_MIN_ID_DESC
  RECORD_MAX_ID_USER_ASC
  RECORD_MAX_ID_USER_DESC
  RECORD_MIN_ID_USER_ASC
  RECORD_MIN_ID_USER_DESC
  RECORD_MAX_TIME_ASC
  RECORD_MAX_TIME_DESC
  RECORD_MIN_TIME_ASC
  RECORD_MIN_TIME_DESC
  RECORD_MAX_GAME_VERSION_ASC
  RECORD_MAX_GAME_VERSION_DESC
  RECORD_MIN_GAME_VERSION_ASC
  RECORD_MIN_GAME_VERSION_DESC
  RECORD_MAX_ID_LEVEL_ASC
  RECORD_MAX_ID_LEVEL_DESC
  RECORD_MIN_ID_LEVEL_ASC
  RECORD_MIN_ID_LEVEL_DESC
  RECORD_MAX_MOD_VERSION_ASC
  RECORD_MAX_MOD_VERSION_DESC
  RECORD_MIN_MOD_VERSION_ASC
  RECORD_MIN_MOD_VERSION_DESC
  RECORD_MAX_DATE_CREATED_ASC
  RECORD_MAX_DATE_CREATED_DESC
  RECORD_MIN_DATE_CREATED_ASC
  RECORD_MIN_DATE_CREATED_DESC
  RECORD_MAX_DATE_UPDATED_ASC
  RECORD_MAX_DATE_UPDATED_DESC
  RECORD_MIN_DATE_UPDATED_ASC
  RECORD_MIN_DATE_UPDATED_DESC
  RECORD_MAX_SPLITS_ASC
  RECORD_MAX_SPLITS_DESC
  RECORD_MIN_SPLITS_ASC
  RECORD_MIN_SPLITS_DESC
  RECORD_MAX_SPEEDS_ASC
  RECORD_MAX_SPEEDS_DESC
  RECORD_MIN_SPEEDS_ASC
  RECORD_MIN_SPEEDS_DESC
  WORLD_RECORD_GLOBAL_COUNT_ASC
  WORLD_RECORD_GLOBAL_COUNT_DESC
  WORLD_RECORD_GLOBAL_MAX_ID_ASC
  WORLD_RECORD_GLOBAL_MAX_ID_DESC
  WORLD_RECORD_GLOBAL_MIN_ID_ASC
  WORLD_RECORD_GLOBAL_MIN_ID_DESC
  WORLD_RECORD_GLOBAL_MAX_ID_RECORD_ASC
  WORLD_RECORD_GLOBAL_MAX_ID_RECORD_DESC
  WORLD_RECORD_GLOBAL_MIN_ID_RECORD_ASC
  WORLD_RECORD_GLOBAL_MIN_ID_RECORD_DESC
  WORLD_RECORD_GLOBAL_MAX_ID_LEVEL_ASC
  WORLD_RECORD_GLOBAL_MAX_ID_LEVEL_DESC
  WORLD_RECORD_GLOBAL_MIN_ID_LEVEL_ASC
  WORLD_RECORD_GLOBAL_MIN_ID_LEVEL_DESC
  WORLD_RECORD_GLOBAL_MAX_DATE_CREATED_ASC
  WORLD_RECORD_GLOBAL_MAX_DATE_CREATED_DESC
  WORLD_RECORD_GLOBAL_MIN_DATE_CREATED_ASC
  WORLD_RECORD_GLOBAL_MIN_DATE_CREATED_DESC
  WORLD_RECORD_GLOBAL_MAX_DATE_UPDATED_ASC
  WORLD_RECORD_GLOBAL_MAX_DATE_UPDATED_DESC
  WORLD_RECORD_GLOBAL_MIN_DATE_UPDATED_ASC
  WORLD_RECORD_GLOBAL_MIN_DATE_UPDATED_DESC
  WORLD_RECORD_GLOBAL_MAX_ID_USER_ASC
  WORLD_RECORD_GLOBAL_MAX_ID_USER_DESC
  WORLD_RECORD_GLOBAL_MIN_ID_USER_ASC
  WORLD_RECORD_GLOBAL_MIN_ID_USER_DESC
  VOTE_COUNT_ASC
  VOTE_COUNT_DESC
  VOTE_MAX_ID_ASC
  VOTE_MAX_ID_DESC
  VOTE_MIN_ID_ASC
  VOTE_MIN_ID_DESC
  VOTE_MAX_ID_USER_ASC
  VOTE_MAX_ID_USER_DESC
  VOTE_MIN_ID_USER_ASC
  VOTE_MIN_ID_USER_DESC
  VOTE_MAX_ID_LEVEL_ASC
  VOTE_MAX_ID_LEVEL_DESC
  VOTE_MIN_ID_LEVEL_ASC
  VOTE_MIN_ID_LEVEL_DESC
  VOTE_MAX_VALUE_ASC
  VOTE_MAX_VALUE_DESC
  VOTE_MIN_VALUE_ASC
  VOTE_MIN_VALUE_DESC
  VOTE_MAX_DATE_CREATED_ASC
  VOTE_MAX_DATE_CREATED_DESC
  VOTE_MIN_DATE_CREATED_ASC
  VOTE_MIN_DATE_CREATED_DESC
  VOTE_MAX_DATE_UPDATED_ASC
  VOTE_MAX_DATE_UPDATED_DESC
  VOTE_MIN_DATE_UPDATED_ASC
  VOTE_MIN_DATE_UPDATED_DESC
  LEVEL_POINTS_HISTORY_COUNT_ASC
  LEVEL_POINTS_HISTORY_COUNT_DESC
  LEVEL_POINTS_HISTORY_MAX_ID_ASC
  LEVEL_POINTS_HISTORY_MAX_ID_DESC
  LEVEL_POINTS_HISTORY_MIN_ID_ASC
  LEVEL_POINTS_HISTORY_MIN_ID_DESC
  LEVEL_POINTS_HISTORY_MAX_ID_LEVEL_ASC
  LEVEL_POINTS_HISTORY_MAX_ID_LEVEL_DESC
  LEVEL_POINTS_HISTORY_MIN_ID_LEVEL_ASC
  LEVEL_POINTS_HISTORY_MIN_ID_LEVEL_DESC
  LEVEL_POINTS_HISTORY_MAX_POINTS_ASC
  LEVEL_POINTS_HISTORY_MAX_POINTS_DESC
  LEVEL_POINTS_HISTORY_MIN_POINTS_ASC
  LEVEL_POINTS_HISTORY_MIN_POINTS_DESC
  LEVEL_POINTS_HISTORY_MAX_DATE_CREATED_ASC
  LEVEL_POINTS_HISTORY_MAX_DATE_CREATED_DESC
  LEVEL_POINTS_HISTORY_MIN_DATE_CREATED_ASC
  LEVEL_POINTS_HISTORY_MIN_DATE_CREATED_DESC
}

"A condition to be used against `Level` object types. All fields are tested for equality and combined with a logical ‘and.’"
input LevelCondition {
  "Checks for equality with the object’s `id` field."
  id: Int
  "Checks for equality with the object’s `hash` field."
  hash: String
  "Checks for equality with the object’s `dateCreated` field."
  dateCreated: Datetime
  "Checks for equality with the object’s `dateUpdated` field."
  dateUpdated: Datetime
}

"A connection to a list of `Level` values, with data from `WorldRecordGlobal`."
type RecordLevelsByWorldRecordGlobalManyToManyConnection {
  "A list of `Level` objects."
  nodes: [Level!]!
  "A list of edges which contains the `Level`, info from the `WorldRecordGlobal`, and the cursor to aid in pagination."
  edges: [RecordLevelsByWorldRecordGlobalManyToManyEdge!]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `Level` you could get from the connection."
  totalCount: Int!
}

"A `Level` edge in the connection, with data from `WorldRecordGlobal`."
type RecordLevelsByWorldRecordGlobalManyToManyEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `Level` at the end of the edge."
  node: Level!
  "Reads and enables pagination through a set of `WorldRecordGlobal`."
  worldRecordGlobals("Only read the first `n` values of the set." first: Int "Only read the last `n` values of the set." last: Int "Skip the first `n` values from our `after` cursor, an alternative to cursor\nbased pagination. May not be used with `last`." offset: Int "Read all values in the set before (above) this cursor." before: Cursor "Read all values in the set after (below) this cursor." after: Cursor "The method to use when ordering `WorldRecordGlobal`." orderBy: [WorldRecordGlobalsOrderBy!] = [ PRIMARY_KEY_ASC ] "A condition to be used in determining which values should be returned by the collection." condition: WorldRecordGlobalCondition "A filter to be used in determining which values should be returned by the collection." filter: WorldRecordGlobalFilter): WorldRecordGlobalsConnection!
}

"A connection to a list of `User` values, with data from `WorldRecordGlobal`."
type RecordUsersByWorldRecordGlobalManyToManyConnection {
  "A list of `User` objects."
  nodes: [User!]!
  "A list of edges which contains the `User`, info from the `WorldRecordGlobal`, and the cursor to aid in pagination."
  edges: [RecordUsersByWorldRecordGlobalManyToManyEdge!]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `User` you could get from the connection."
  totalCount: Int!
}

"A `User` edge in the connection, with data from `WorldRecordGlobal`."
type RecordUsersByWorldRecordGlobalManyToManyEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `User` at the end of the edge."
  node: User!
  "Reads and enables pagination through a set of `WorldRecordGlobal`."
  worldRecordGlobals("Only read the first `n` values of the set." first: Int "Only read the last `n` values of the set." last: Int "Skip the first `n` values from our `after` cursor, an alternative to cursor\nbased pagination. May not be used with `last`." offset: Int "Read all values in the set before (above) this cursor." before: Cursor "Read all values in the set after (below) this cursor." after: Cursor "The method to use when ordering `WorldRecordGlobal`." orderBy: [WorldRecordGlobalsOrderBy!] = [ PRIMARY_KEY_ASC ] "A condition to be used in determining which values should be returned by the collection." condition: WorldRecordGlobalCondition "A filter to be used in determining which values should be returned by the collection." filter: WorldRecordGlobalFilter): WorldRecordGlobalsConnection!
}

"A `PersonalBestGlobal` edge in the connection."
type PersonalBestGlobalsEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `PersonalBestGlobal` at the end of the edge."
  node: PersonalBestGlobal!
}

"A connection to a list of `UserPoint` values."
type UserPointsConnection {
  "A list of `UserPoint` objects."
  nodes: [UserPoint!]!
  "A list of edges which contains the `UserPoint` and cursor to aid in pagination."
  edges: [UserPointsEdge!]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `UserPoint` you could get from the connection."
  totalCount: Int!
}

type UserPoint implements Node {
  "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
  nodeId: ID!
  id: Int!
  userId: Int!
  points: Int!
  dateCreated: Datetime!
  dateUpdated: Datetime
  rank: Int!
  worldRecords: Int!
  totalPoints: Int!
  "Reads a single `User` that is related to this `UserPoint`."
  user: User
}

"A `UserPoint` edge in the connection."
type UserPointsEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `UserPoint` at the end of the edge."
  node: UserPoint!
}

"Methods to use when ordering `UserPoint`."
enum UserPointsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  ID_USER_ASC
  ID_USER_DESC
  POINTS_ASC
  POINTS_DESC
  DATE_CREATED_ASC
  DATE_CREATED_DESC
  DATE_UPDATED_ASC
  DATE_UPDATED_DESC
  RANK_ASC
  RANK_DESC
  WORLD_RECORDS_ASC
  WORLD_RECORDS_DESC
  TOTAL_POINTS_ASC
  TOTAL_POINTS_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  USER_ID_ASC
  USER_ID_DESC
  USER_STEAM_NAME_ASC
  USER_STEAM_NAME_DESC
  USER_BANNED_ASC
  USER_BANNED_DESC
  USER_DATE_CREATED_ASC
  USER_DATE_CREATED_DESC
  USER_DATE_UPDATED_ASC
  USER_DATE_UPDATED_DESC
  USER_STEAM_ID_ASC
  USER_STEAM_ID_DESC
  USER_DISCORD_ID_ASC
  USER_DISCORD_ID_DESC
}

"A condition to be used against `UserPoint` object types. All fields are tested\nfor equality and combined with a logical ‘and.’"
input UserPointCondition {
  "Checks for equality with the object’s `id` field."
  id: Int
  "Checks for equality with the object’s `userId` field."
  userId: Int
  "Checks for equality with the object’s `points` field."
  points: Int
  "Checks for equality with the object’s `dateCreated` field."
  dateCreated: Datetime
  "Checks for equality with the object’s `dateUpdated` field."
  dateUpdated: Datetime
  "Checks for equality with the object’s `rank` field."
  rank: Int
  "Checks for equality with the object’s `worldRecords` field."
  worldRecords: Int
  "Checks for equality with the object’s `totalPoints` field."
  totalPoints: Int
}

"A connection to a list of `UserPointsHistory` values."
type UserPointsHistoriesConnection {
  "A list of `UserPointsHistory` objects."
  nodes: [UserPointsHistory!]!
  "A list of edges which contains the `UserPointsHistory` and cursor to aid in pagination."
  edges: [UserPointsHistoriesEdge!]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `UserPointsHistory` you could get from the connection."
  totalCount: Int!
}

type UserPointsHistory implements Node {
  "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
  nodeId: ID!
  id: Int!
  userId: Int!
  points: Int!
  totalPoints: Int!
  rank: Int!
  worldRecords: Int!
  dateCreated: Datetime!
  "Reads a single `User` that is related to this `UserPointsHistory`."
  user: User
}

"A `UserPointsHistory` edge in the connection."
type UserPointsHistoriesEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `UserPointsHistory` at the end of the edge."
  node: UserPointsHistory!
}

"Methods to use when ordering `UserPointsHistory`."
enum UserPointsHistoriesOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  ID_USER_ASC
  ID_USER_DESC
  POINTS_ASC
  POINTS_DESC
  TOTAL_POINTS_ASC
  TOTAL_POINTS_DESC
  RANK_ASC
  RANK_DESC
  WORLD_RECORDS_ASC
  WORLD_RECORDS_DESC
  DATE_CREATED_ASC
  DATE_CREATED_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  USER_ID_ASC
  USER_ID_DESC
  USER_STEAM_NAME_ASC
  USER_STEAM_NAME_DESC
  USER_BANNED_ASC
  USER_BANNED_DESC
  USER_DATE_CREATED_ASC
  USER_DATE_CREATED_DESC
  USER_DATE_UPDATED_ASC
  USER_DATE_UPDATED_DESC
  USER_STEAM_ID_ASC
  USER_STEAM_ID_DESC
  USER_DISCORD_ID_ASC
  USER_DISCORD_ID_DESC
}

"A condition to be used against `UserPointsHistory` object types. All fields are\ntested for equality and combined with a logical ‘and.’"
input UserPointsHistoryCondition {
  "Checks for equality with the object’s `id` field."
  id: Int
  "Checks for equality with the object’s `userId` field."
  userId: Int
  "Checks for equality with the object’s `points` field."
  points: Int
  "Checks for equality with the object’s `totalPoints` field."
  totalPoints: Int
  "Checks for equality with the object’s `rank` field."
  rank: Int
  "Checks for equality with the object’s `worldRecords` field."
  worldRecords: Int
  "Checks for equality with the object’s `dateCreated` field."
  dateCreated: Datetime
}

"A connection to a list of `Level` values, with data from `Favourite`."
type UserLevelsByFavouriteManyToManyConnection {
  "A list of `Level` objects."
  nodes: [Level!]!
  "A list of edges which contains the `Level`, info from the `Favourite`, and the cursor to aid in pagination."
  edges: [UserLevelsByFavouriteManyToManyEdge!]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `Level` you could get from the connection."
  totalCount: Int!
}

"A `Level` edge in the connection, with data from `Favourite`."
type UserLevelsByFavouriteManyToManyEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `Level` at the end of the edge."
  node: Level!
  "Reads and enables pagination through a set of `Favourite`."
  favourites("Only read the first `n` values of the set." first: Int "Only read the last `n` values of the set." last: Int "Skip the first `n` values from our `after` cursor, an alternative to cursor\nbased pagination. May not be used with `last`." offset: Int "Read all values in the set before (above) this cursor." before: Cursor "Read all values in the set after (below) this cursor." after: Cursor "The method to use when ordering `Favourite`." orderBy: [FavouritesOrderBy!] = [ PRIMARY_KEY_ASC ] "A condition to be used in determining which values should be returned by the collection." condition: FavouriteCondition "A filter to be used in determining which values should be returned by the collection." filter: FavouriteFilter): FavouritesConnection!
}

"A connection to a list of `Record` values, with data from `PersonalBestGlobal`."
type UserRecordsByPersonalBestGlobalManyToManyConnection {
  "A list of `Record` objects."
  nodes: [Record!]!
  "A list of edges which contains the `Record`, info from the `PersonalBestGlobal`, and the cursor to aid in pagination."
  edges: [UserRecordsByPersonalBestGlobalManyToManyEdge!]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `Record` you could get from the connection."
  totalCount: Int!
}

"A `Record` edge in the connection, with data from `PersonalBestGlobal`."
type UserRecordsByPersonalBestGlobalManyToManyEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `Record` at the end of the edge."
  node: Record!
  "Reads and enables pagination through a set of `PersonalBestGlobal`."
  personalBestGlobals("Only read the first `n` values of the set." first: Int "Only read the last `n` values of the set." last: Int "Skip the first `n` values from our `after` cursor, an alternative to cursor\nbased pagination. May not be used with `last`." offset: Int "Read all values in the set before (above) this cursor." before: Cursor "Read all values in the set after (below) this cursor." after: Cursor "The method to use when ordering `PersonalBestGlobal`." orderBy: [PersonalBestGlobalsOrderBy!] = [ PRIMARY_KEY_ASC ] "A condition to be used in determining which values should be returned by the collection." condition: PersonalBestGlobalCondition "A filter to be used in determining which values should be returned by the collection." filter: PersonalBestGlobalFilter): PersonalBestGlobalsConnection!
}

"A connection to a list of `Level` values, with data from `PersonalBestGlobal`."
type UserLevelsByPersonalBestGlobalManyToManyConnection {
  "A list of `Level` objects."
  nodes: [Level!]!
  "A list of edges which contains the `Level`, info from the `PersonalBestGlobal`, and the cursor to aid in pagination."
  edges: [UserLevelsByPersonalBestGlobalManyToManyEdge!]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `Level` you could get from the connection."
  totalCount: Int!
}

"A `Level` edge in the connection, with data from `PersonalBestGlobal`."
type UserLevelsByPersonalBestGlobalManyToManyEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `Level` at the end of the edge."
  node: Level!
  "Reads and enables pagination through a set of `PersonalBestGlobal`."
  personalBestGlobals("Only read the first `n` values of the set." first: Int "Only read the last `n` values of the set." last: Int "Skip the first `n` values from our `after` cursor, an alternative to cursor\nbased pagination. May not be used with `last`." offset: Int "Read all values in the set before (above) this cursor." before: Cursor "Read all values in the set after (below) this cursor." after: Cursor "The method to use when ordering `PersonalBestGlobal`." orderBy: [PersonalBestGlobalsOrderBy!] = [ PRIMARY_KEY_ASC ] "A condition to be used in determining which values should be returned by the collection." condition: PersonalBestGlobalCondition "A filter to be used in determining which values should be returned by the collection." filter: PersonalBestGlobalFilter): PersonalBestGlobalsConnection!
}

"A connection to a list of `Level` values, with data from `Record`."
type UserLevelsByRecordManyToManyConnection {
  "A list of `Level` objects."
  nodes: [Level!]!
  "A list of edges which contains the `Level`, info from the `Record`, and the cursor to aid in pagination."
  edges: [UserLevelsByRecordManyToManyEdge!]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `Level` you could get from the connection."
  totalCount: Int!
}

"A `Level` edge in the connection, with data from `Record`."
type UserLevelsByRecordManyToManyEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `Level` at the end of the edge."
  node: Level!
  "Reads and enables pagination through a set of `Record`."
  records("Only read the first `n` values of the set." first: Int "Only read the last `n` values of the set." last: Int "Skip the first `n` values from our `after` cursor, an alternative to cursor\nbased pagination. May not be used with `last`." offset: Int "Read all values in the set before (above) this cursor." before: Cursor "Read all values in the set after (below) this cursor." after: Cursor "The method to use when ordering `Record`." orderBy: [RecordsOrderBy!] = [ PRIMARY_KEY_ASC ] "A condition to be used in determining which values should be returned by the collection." condition: RecordCondition "A filter to be used in determining which values should be returned by the collection." filter: RecordFilter): RecordsConnection!
}

"A connection to a list of `Record` values, with data from `WorldRecordGlobal`."
type UserRecordsByWorldRecordGlobalManyToManyConnection {
  "A list of `Record` objects."
  nodes: [Record!]!
  "A list of edges which contains the `Record`, info from the `WorldRecordGlobal`, and the cursor to aid in pagination."
  edges: [UserRecordsByWorldRecordGlobalManyToManyEdge!]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `Record` you could get from the connection."
  totalCount: Int!
}

"A `Record` edge in the connection, with data from `WorldRecordGlobal`."
type UserRecordsByWorldRecordGlobalManyToManyEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `Record` at the end of the edge."
  node: Record!
  "Reads and enables pagination through a set of `WorldRecordGlobal`."
  worldRecordGlobals("Only read the first `n` values of the set." first: Int "Only read the last `n` values of the set." last: Int "Skip the first `n` values from our `after` cursor, an alternative to cursor\nbased pagination. May not be used with `last`." offset: Int "Read all values in the set before (above) this cursor." before: Cursor "Read all values in the set after (below) this cursor." after: Cursor "The method to use when ordering `WorldRecordGlobal`." orderBy: [WorldRecordGlobalsOrderBy!] = [ PRIMARY_KEY_ASC ] "A condition to be used in determining which values should be returned by the collection." condition: WorldRecordGlobalCondition "A filter to be used in determining which values should be returned by the collection." filter: WorldRecordGlobalFilter): WorldRecordGlobalsConnection!
}

"A connection to a list of `Level` values, with data from `WorldRecordGlobal`."
type UserLevelsByWorldRecordGlobalManyToManyConnection {
  "A list of `Level` objects."
  nodes: [Level!]!
  "A list of edges which contains the `Level`, info from the `WorldRecordGlobal`, and the cursor to aid in pagination."
  edges: [UserLevelsByWorldRecordGlobalManyToManyEdge!]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `Level` you could get from the connection."
  totalCount: Int!
}

"A `Level` edge in the connection, with data from `WorldRecordGlobal`."
type UserLevelsByWorldRecordGlobalManyToManyEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `Level` at the end of the edge."
  node: Level!
  "Reads and enables pagination through a set of `WorldRecordGlobal`."
  worldRecordGlobals("Only read the first `n` values of the set." first: Int "Only read the last `n` values of the set." last: Int "Skip the first `n` values from our `after` cursor, an alternative to cursor\nbased pagination. May not be used with `last`." offset: Int "Read all values in the set before (above) this cursor." before: Cursor "Read all values in the set after (below) this cursor." after: Cursor "The method to use when ordering `WorldRecordGlobal`." orderBy: [WorldRecordGlobalsOrderBy!] = [ PRIMARY_KEY_ASC ] "A condition to be used in determining which values should be returned by the collection." condition: WorldRecordGlobalCondition "A filter to be used in determining which values should be returned by the collection." filter: WorldRecordGlobalFilter): WorldRecordGlobalsConnection!
}

"A connection to a list of `Level` values, with data from `Vote`."
type UserLevelsByVoteManyToManyConnection {
  "A list of `Level` objects."
  nodes: [Level!]!
  "A list of edges which contains the `Level`, info from the `Vote`, and the cursor to aid in pagination."
  edges: [UserLevelsByVoteManyToManyEdge!]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `Level` you could get from the connection."
  totalCount: Int!
}

"A `Level` edge in the connection, with data from `Vote`."
type UserLevelsByVoteManyToManyEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `Level` at the end of the edge."
  node: Level!
  "Reads and enables pagination through a set of `Vote`."
  votes("Only read the first `n` values of the set." first: Int "Only read the last `n` values of the set." last: Int "Skip the first `n` values from our `after` cursor, an alternative to cursor\nbased pagination. May not be used with `last`." offset: Int "Read all values in the set before (above) this cursor." before: Cursor "Read all values in the set after (below) this cursor." after: Cursor "The method to use when ordering `Vote`." orderBy: [VotesOrderBy!] = [ PRIMARY_KEY_ASC ] "A condition to be used in determining which values should be returned by the collection." condition: VoteCondition "A filter to be used in determining which values should be returned by the collection." filter: VoteFilter): VotesConnection!
}

"A `Favourite` edge in the connection."
type FavouritesEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `Favourite` at the end of the edge."
  node: Favourite!
}

"A connection to a list of `Level` values."
type LevelsConnection {
  "A list of `Level` objects."
  nodes: [Level!]!
  "A list of edges which contains the `Level` and cursor to aid in pagination."
  edges: [LevelsEdge!]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `Level` you could get from the connection."
  totalCount: Int!
}

"A `Level` edge in the connection."
type LevelsEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `Level` at the end of the edge."
  node: Level!
}

"A connection to a list of `LevelRequest` values."
type LevelRequestsConnection {
  "A list of `LevelRequest` objects."
  nodes: [LevelRequest!]!
  "A list of edges which contains the `LevelRequest` and cursor to aid in pagination."
  edges: [LevelRequestsEdge!]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `LevelRequest` you could get from the connection."
  totalCount: Int!
}

type LevelRequest implements Node {
  "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
  nodeId: ID!
  id: Int!
  workshopId: BigInt!
  uid: String
  hash: String
  dateCreated: Datetime!
  dateUpdated: Datetime
}

"A `LevelRequest` edge in the connection."
type LevelRequestsEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `LevelRequest` at the end of the edge."
  node: LevelRequest!
}

"Methods to use when ordering `LevelRequest`."
enum LevelRequestsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  WORKSHOP_ID_ASC
  WORKSHOP_ID_DESC
  UID_ASC
  UID_DESC
  HASH_ASC
  HASH_DESC
  DATE_CREATED_ASC
  DATE_CREATED_DESC
  DATE_UPDATED_ASC
  DATE_UPDATED_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"A condition to be used against `LevelRequest` object types. All fields are\ntested for equality and combined with a logical ‘and.’"
input LevelRequestCondition {
  "Checks for equality with the object’s `id` field."
  id: Int
  "Checks for equality with the object’s `workshopId` field."
  workshopId: BigInt
  "Checks for equality with the object’s `uid` field."
  uid: String
  "Checks for equality with the object’s `hash` field."
  hash: String
  "Checks for equality with the object’s `dateCreated` field."
  dateCreated: Datetime
  "Checks for equality with the object’s `dateUpdated` field."
  dateUpdated: Datetime
}

"A filter to be used against `LevelRequest` object types. All fields are combined with a logical ‘and.’"
input LevelRequestFilter {
  "Filter by the object’s `id` field."
  id: IntFilter
  "Filter by the object’s `workshopId` field."
  workshopId: BigIntFilter
  "Filter by the object’s `uid` field."
  uid: StringFilter
  "Filter by the object’s `hash` field."
  hash: StringFilter
  "Filter by the object’s `dateCreated` field."
  dateCreated: DatetimeFilter
  "Filter by the object’s `dateUpdated` field."
  dateUpdated: DatetimeFilter
  "Checks for all expressions in this list."
  and: [LevelRequestFilter!]
  "Checks for any expressions in this list."
  or: [LevelRequestFilter!]
  "Negates the expression."
  not: LevelRequestFilter
}

"A connection to a list of `User` values."
type UsersConnection {
  "A list of `User` objects."
  nodes: [User!]!
  "A list of edges which contains the `User` and cursor to aid in pagination."
  edges: [UsersEdge!]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `User` you could get from the connection."
  totalCount: Int!
}

"A `User` edge in the connection."
type UsersEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `User` at the end of the edge."
  node: User!
}

"A connection to a list of `Version` values."
type VersionsConnection {
  "A list of `Version` objects."
  nodes: [Version!]!
  "A list of edges which contains the `Version` and cursor to aid in pagination."
  edges: [VersionsEdge!]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `Version` you could get from the connection."
  totalCount: Int!
}

type Version implements Node {
  "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
  nodeId: ID!
  id: Int!
  minimum: String
  latest: String
  dateCreated: Datetime!
  dateUpdated: Datetime
}

"A `Version` edge in the connection."
type VersionsEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `Version` at the end of the edge."
  node: Version!
}

"Methods to use when ordering `Version`."
enum VersionsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  MINIMUM_ASC
  MINIMUM_DESC
  LATEST_ASC
  LATEST_DESC
  DATE_CREATED_ASC
  DATE_CREATED_DESC
  DATE_UPDATED_ASC
  DATE_UPDATED_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"A condition to be used against `Version` object types. All fields are tested for equality and combined with a logical ‘and.’"
input VersionCondition {
  "Checks for equality with the object’s `id` field."
  id: Int
  "Checks for equality with the object’s `minimum` field."
  minimum: String
  "Checks for equality with the object’s `latest` field."
  latest: String
  "Checks for equality with the object’s `dateCreated` field."
  dateCreated: Datetime
  "Checks for equality with the object’s `dateUpdated` field."
  dateUpdated: Datetime
}

"A filter to be used against `Version` object types. All fields are combined with a logical ‘and.’"
input VersionFilter {
  "Filter by the object’s `id` field."
  id: IntFilter
  "Filter by the object’s `minimum` field."
  minimum: StringFilter
  "Filter by the object’s `latest` field."
  latest: StringFilter
  "Filter by the object’s `dateCreated` field."
  dateCreated: DatetimeFilter
  "Filter by the object’s `dateUpdated` field."
  dateUpdated: DatetimeFilter
  "Checks for all expressions in this list."
  and: [VersionFilter!]
  "Checks for any expressions in this list."
  or: [VersionFilter!]
  "Negates the expression."
  not: VersionFilter
}

"A connection to a list of `ZRtmRecord` values."
type ZRtmConnection {
  "A list of `ZRtmRecord` objects."
  nodes: [ZRtmRecord!]!
  "A list of edges which contains the `ZRtmRecord` and cursor to aid in pagination."
  edges: [ZRtmEdge!]!
  "The count of *all* `ZRtmRecord` you could get from the connection."
  totalCount: Int!
}

"The return type of our `zRtm` query."
type ZRtmRecord {
  id: Int
  idLevel: Int
  workshopId: BigFloat
  authorId: BigFloat
  name: String
  imageUrl: String
  fileAuthor: String
  fileUid: String
  validationTimeAuthor: Float
  validationTimeGold: Float
  validationTimeSilver: Float
  validationTimeBronze: Float
  deleted: Boolean
  createdAt: Datetime
  updatedAt: Datetime
  dateCreated: Datetime
  dateUpdated: Datetime
  amountCheckpoints: Int
  amountFinishes: Int
  amountBlocks: Int
  numRecords: BigInt
}

"A `ZRtmRecord` edge in the connection."
type ZRtmEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `ZRtmRecord` at the end of the edge."
  node: ZRtmRecord!
}

"A filter to be used against `ZRtmRecord` object types. All fields are combined with a logical ‘and.’"
input ZRtmRecordFilter {
  "Filter by the object’s `id` field."
  id: IntFilter
  "Filter by the object’s `idLevel` field."
  idLevel: IntFilter
  "Filter by the object’s `workshopId` field."
  workshopId: BigFloatFilter
  "Filter by the object’s `authorId` field."
  authorId: BigFloatFilter
  "Filter by the object’s `name` field."
  name: StringFilter
  "Filter by the object’s `imageUrl` field."
  imageUrl: StringFilter
  "Filter by the object’s `fileAuthor` field."
  fileAuthor: StringFilter
  "Filter by the object’s `fileUid` field."
  fileUid: StringFilter
  "Filter by the object’s `validationTimeAuthor` field."
  validationTimeAuthor: FloatFilter
  "Filter by the object’s `validationTimeGold` field."
  validationTimeGold: FloatFilter
  "Filter by the object’s `validationTimeSilver` field."
  validationTimeSilver: FloatFilter
  "Filter by the object’s `validationTimeBronze` field."
  validationTimeBronze: FloatFilter
  "Filter by the object’s `deleted` field."
  deleted: BooleanFilter
  "Filter by the object’s `createdAt` field."
  createdAt: DatetimeFilter
  "Filter by the object’s `updatedAt` field."
  updatedAt: DatetimeFilter
  "Filter by the object’s `dateCreated` field."
  dateCreated: DatetimeFilter
  "Filter by the object’s `dateUpdated` field."
  dateUpdated: DatetimeFilter
  "Filter by the object’s `amountCheckpoints` field."
  amountCheckpoints: IntFilter
  "Filter by the object’s `amountFinishes` field."
  amountFinishes: IntFilter
  "Filter by the object’s `amountBlocks` field."
  amountBlocks: IntFilter
  "Filter by the object’s `numRecords` field."
  numRecords: BigIntFilter
  "Checks for all expressions in this list."
  and: [ZRtmRecordFilter!]
  "Checks for any expressions in this list."
  or: [ZRtmRecordFilter!]
  "Negates the expression."
  not: ZRtmRecordFilter
}

"The root mutation type which contains root level fields which mutate data."
type Mutation {
  updateWorldRecordGlobal("The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields." input: UpdateWorldRecordGlobalInput!): UpdateWorldRecordGlobalPayload
}

"The output of our `updateWorldRecordGlobal` mutation."
type UpdateWorldRecordGlobalPayload {
  "The exact same `clientMutationId` that was provided in the mutation input,\nunchanged and unused. May be used by a client to track mutations."
  clientMutationId: String
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
}

"All input for the `updateWorldRecordGlobal` mutation."
input UpdateWorldRecordGlobalInput {
  "An arbitrary string value with no semantic meaning. Will be included in the\npayload verbatim. May be used to track mutations by the client."
  clientMutationId: String
}

"The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.\n\n#### Live Queries\n\nLive query fields are differentiated by containing `(live)` at the end of their\ndescription, they are added for each field in the `Query` type. When you\nsubscribe to a live query field, the selection set will be evaluated and sent to\nthe client, and then most things\\* that would cause the output of the selection\nset to change will trigger the selection set to be re-evaluated and the results\nto be re-sent to the client.\n\n_(\\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_\n\nLive queries can be very expensive, so try and keep them small and focussed.\n\n#### Events\n\nEvent fields will run their selection set when, and only when, the specified\nserver-side event occurs. This makes them a lot more efficient than Live\nQueries, but it is still recommended that you keep payloads fairly small."
type Subscription {
  "Exposes the root query type nested one level down. This is helpful for Relay 1\nwhich can only query top level fields if they are in a particular form. (live)"
  query: Query!
  "The root query type must be a `Node` to work well with Relay 1 mutations. This just resolves to `query`. (live)"
  nodeId: ID!
  "Fetches an object given its globally unique `ID`. (live)"
  node("The globally unique `ID`." nodeId: ID!): Node
  "Reads and enables pagination through a set of `Favourite`. (live)"
  favourites("Only read the first `n` values of the set." first: Int "Only read the last `n` values of the set." last: Int "Skip the first `n` values from our `after` cursor, an alternative to cursor\nbased pagination. May not be used with `last`." offset: Int "Read all values in the set before (above) this cursor." before: Cursor "Read all values in the set after (below) this cursor." after: Cursor "The method to use when ordering `Favourite`." orderBy: [FavouritesOrderBy!] = [ PRIMARY_KEY_ASC ] "A condition to be used in determining which values should be returned by the collection." condition: FavouriteCondition "A filter to be used in determining which values should be returned by the collection." filter: FavouriteFilter): FavouritesConnection
  "Reads and enables pagination through a set of `Level`. (live)"
  levels("Only read the first `n` values of the set." first: Int "Only read the last `n` values of the set." last: Int "Skip the first `n` values from our `after` cursor, an alternative to cursor\nbased pagination. May not be used with `last`." offset: Int "Read all values in the set before (above) this cursor." before: Cursor "Read all values in the set after (below) this cursor." after: Cursor "The method to use when ordering `Level`." orderBy: [LevelsOrderBy!] = [ PRIMARY_KEY_ASC ] "A condition to be used in determining which values should be returned by the collection." condition: LevelCondition "A filter to be used in determining which values should be returned by the collection." filter: LevelFilter): LevelsConnection
  "Reads and enables pagination through a set of `LevelItem`. (live)"
  levelItems("Only read the first `n` values of the set." first: Int "Only read the last `n` values of the set." last: Int "Skip the first `n` values from our `after` cursor, an alternative to cursor\nbased pagination. May not be used with `last`." offset: Int "Read all values in the set before (above) this cursor." before: Cursor "Read all values in the set after (below) this cursor." after: Cursor "The method to use when ordering `LevelItem`." orderBy: [LevelItemsOrderBy!] = [ PRIMARY_KEY_ASC ] "A condition to be used in determining which values should be returned by the collection." condition: LevelItemCondition "A filter to be used in determining which values should be returned by the collection." filter: LevelItemFilter): LevelItemsConnection
  "Reads and enables pagination through a set of `LevelMetadatum`. (live)"
  levelMetadata("Only read the first `n` values of the set." first: Int "Only read the last `n` values of the set." last: Int "Skip the first `n` values from our `after` cursor, an alternative to cursor\nbased pagination. May not be used with `last`." offset: Int "Read all values in the set before (above) this cursor." before: Cursor "Read all values in the set after (below) this cursor." after: Cursor "The method to use when ordering `LevelMetadatum`." orderBy: [LevelMetadataOrderBy!] = [ PRIMARY_KEY_ASC ] "A condition to be used in determining which values should be returned by the collection." condition: LevelMetadatumCondition "A filter to be used in determining which values should be returned by the collection." filter: LevelMetadatumFilter): LevelMetadataConnection
  "Reads and enables pagination through a set of `LevelPoint`. (live)"
  levelPoints("Only read the first `n` values of the set." first: Int "Only read the last `n` values of the set." last: Int "Skip the first `n` values from our `after` cursor, an alternative to cursor\nbased pagination. May not be used with `last`." offset: Int "Read all values in the set before (above) this cursor." before: Cursor "Read all values in the set after (below) this cursor." after: Cursor "The method to use when ordering `LevelPoint`." orderBy: [LevelPointsOrderBy!] = [ PRIMARY_KEY_ASC ] "A condition to be used in determining which values should be returned by the collection." condition: LevelPointCondition "A filter to be used in determining which values should be returned by the collection." filter: LevelPointFilter): LevelPointsConnection
  "Reads and enables pagination through a set of `LevelPointsHistory`. (live)"
  levelPointsHistories("Only read the first `n` values of the set." first: Int "Only read the last `n` values of the set." last: Int "Skip the first `n` values from our `after` cursor, an alternative to cursor\nbased pagination. May not be used with `last`." offset: Int "Read all values in the set before (above) this cursor." before: Cursor "Read all values in the set after (below) this cursor." after: Cursor "The method to use when ordering `LevelPointsHistory`." orderBy: [LevelPointsHistoriesOrderBy!] = [ PRIMARY_KEY_ASC ] "A condition to be used in determining which values should be returned by the collection." condition: LevelPointsHistoryCondition "A filter to be used in determining which values should be returned by the collection." filter: LevelPointsHistoryFilter): LevelPointsHistoriesConnection
  "Reads and enables pagination through a set of `LevelRequest`. (live)"
  levelRequests("Only read the first `n` values of the set." first: Int "Only read the last `n` values of the set." last: Int "Skip the first `n` values from our `after` cursor, an alternative to cursor\nbased pagination. May not be used with `last`." offset: Int "Read all values in the set before (above) this cursor." before: Cursor "Read all values in the set after (below) this cursor." after: Cursor "The method to use when ordering `LevelRequest`." orderBy: [LevelRequestsOrderBy!] = [ PRIMARY_KEY_ASC ] "A condition to be used in determining which values should be returned by the collection." condition: LevelRequestCondition "A filter to be used in determining which values should be returned by the collection." filter: LevelRequestFilter): LevelRequestsConnection
  "Reads and enables pagination through a set of `PersonalBestGlobal`. (live)"
  personalBestGlobals("Only read the first `n` values of the set." first: Int "Only read the last `n` values of the set." last: Int "Skip the first `n` values from our `after` cursor, an alternative to cursor\nbased pagination. May not be used with `last`." offset: Int "Read all values in the set before (above) this cursor." before: Cursor "Read all values in the set after (below) this cursor." after: Cursor "The method to use when ordering `PersonalBestGlobal`." orderBy: [PersonalBestGlobalsOrderBy!] = [ PRIMARY_KEY_ASC ] "A condition to be used in determining which values should be returned by the collection." condition: PersonalBestGlobalCondition "A filter to be used in determining which values should be returned by the collection." filter: PersonalBestGlobalFilter): PersonalBestGlobalsConnection
  "Reads and enables pagination through a set of `Record`. (live)"
  records("Only read the first `n` values of the set." first: Int "Only read the last `n` values of the set." last: Int "Skip the first `n` values from our `after` cursor, an alternative to cursor\nbased pagination. May not be used with `last`." offset: Int "Read all values in the set before (above) this cursor." before: Cursor "Read all values in the set after (below) this cursor." after: Cursor "The method to use when ordering `Record`." orderBy: [RecordsOrderBy!] = [ PRIMARY_KEY_ASC ] "A condition to be used in determining which values should be returned by the collection." condition: RecordCondition "A filter to be used in determining which values should be returned by the collection." filter: RecordFilter): RecordsConnection
  "Reads and enables pagination through a set of `RecordMedia`. (live)"
  recordMedias("Only read the first `n` values of the set." first: Int "Only read the last `n` values of the set." last: Int "Skip the first `n` values from our `after` cursor, an alternative to cursor\nbased pagination. May not be used with `last`." offset: Int "Read all values in the set before (above) this cursor." before: Cursor "Read all values in the set after (below) this cursor." after: Cursor "The method to use when ordering `RecordMedia`." orderBy: [RecordMediaOrderBy!] = [ PRIMARY_KEY_ASC ] "A condition to be used in determining which values should be returned by the collection." condition: RecordMediaCondition "A filter to be used in determining which values should be returned by the collection." filter: RecordMediaFilter): RecordMediaConnection
  "Reads and enables pagination through a set of `User`. (live)"
  users("Only read the first `n` values of the set." first: Int "Only read the last `n` values of the set." last: Int "Skip the first `n` values from our `after` cursor, an alternative to cursor\nbased pagination. May not be used with `last`." offset: Int "Read all values in the set before (above) this cursor." before: Cursor "Read all values in the set after (below) this cursor." after: Cursor "The method to use when ordering `User`." orderBy: [UsersOrderBy!] = [ PRIMARY_KEY_ASC ] "A condition to be used in determining which values should be returned by the collection." condition: UserCondition "A filter to be used in determining which values should be returned by the collection." filter: UserFilter): UsersConnection
  "Reads and enables pagination through a set of `UserPoint`. (live)"
  userPoints("Only read the first `n` values of the set." first: Int "Only read the last `n` values of the set." last: Int "Skip the first `n` values from our `after` cursor, an alternative to cursor\nbased pagination. May not be used with `last`." offset: Int "Read all values in the set before (above) this cursor." before: Cursor "Read all values in the set after (below) this cursor." after: Cursor "The method to use when ordering `UserPoint`." orderBy: [UserPointsOrderBy!] = [ PRIMARY_KEY_ASC ] "A condition to be used in determining which values should be returned by the collection." condition: UserPointCondition "A filter to be used in determining which values should be returned by the collection." filter: UserPointFilter): UserPointsConnection
  "Reads and enables pagination through a set of `UserPointsHistory`. (live)"
  userPointsHistories("Only read the first `n` values of the set." first: Int "Only read the last `n` values of the set." last: Int "Skip the first `n` values from our `after` cursor, an alternative to cursor\nbased pagination. May not be used with `last`." offset: Int "Read all values in the set before (above) this cursor." before: Cursor "Read all values in the set after (below) this cursor." after: Cursor "The method to use when ordering `UserPointsHistory`." orderBy: [UserPointsHistoriesOrderBy!] = [ PRIMARY_KEY_ASC ] "A condition to be used in determining which values should be returned by the collection." condition: UserPointsHistoryCondition "A filter to be used in determining which values should be returned by the collection." filter: UserPointsHistoryFilter): UserPointsHistoriesConnection
  "Reads and enables pagination through a set of `Version`. (live)"
  versions("Only read the first `n` values of the set." first: Int "Only read the last `n` values of the set." last: Int "Skip the first `n` values from our `after` cursor, an alternative to cursor\nbased pagination. May not be used with `last`." offset: Int "Read all values in the set before (above) this cursor." before: Cursor "Read all values in the set after (below) this cursor." after: Cursor "The method to use when ordering `Version`." orderBy: [VersionsOrderBy!] = [ PRIMARY_KEY_ASC ] "A condition to be used in determining which values should be returned by the collection." condition: VersionCondition "A filter to be used in determining which values should be returned by the collection." filter: VersionFilter): VersionsConnection
  "Reads and enables pagination through a set of `Vote`. (live)"
  votes("Only read the first `n` values of the set." first: Int "Only read the last `n` values of the set." last: Int "Skip the first `n` values from our `after` cursor, an alternative to cursor\nbased pagination. May not be used with `last`." offset: Int "Read all values in the set before (above) this cursor." before: Cursor "Read all values in the set after (below) this cursor." after: Cursor "The method to use when ordering `Vote`." orderBy: [VotesOrderBy!] = [ PRIMARY_KEY_ASC ] "A condition to be used in determining which values should be returned by the collection." condition: VoteCondition "A filter to be used in determining which values should be returned by the collection." filter: VoteFilter): VotesConnection
  "Reads and enables pagination through a set of `WorldRecordGlobal`. (live)"
  worldRecordGlobals("Only read the first `n` values of the set." first: Int "Only read the last `n` values of the set." last: Int "Skip the first `n` values from our `after` cursor, an alternative to cursor\nbased pagination. May not be used with `last`." offset: Int "Read all values in the set before (above) this cursor." before: Cursor "Read all values in the set after (below) this cursor." after: Cursor "The method to use when ordering `WorldRecordGlobal`." orderBy: [WorldRecordGlobalsOrderBy!] = [ PRIMARY_KEY_ASC ] "A condition to be used in determining which values should be returned by the collection." condition: WorldRecordGlobalCondition "A filter to be used in determining which values should be returned by the collection." filter: WorldRecordGlobalFilter): WorldRecordGlobalsConnection
  " (live)"
  favourite(id: Int!): Favourite
  " (live)"
  level(id: Int!): Level
  " (live)"
  levelByHash(hash: String!): Level
  " (live)"
  levelItem(id: Int!): LevelItem
  " (live)"
  levelMetadatum(id: Int!): LevelMetadatum
  " (live)"
  levelPoint(id: Int!): LevelPoint
  " (live)"
  levelPointsHistory(id: Int!): LevelPointsHistory
  " (live)"
  levelRequest(id: Int!): LevelRequest
  " (live)"
  personalBestGlobal(id: Int!): PersonalBestGlobal
  " (live)"
  record(id: Int!): Record
  " (live)"
  recordMedia(id: Int!): RecordMedia
  " (live)"
  recordMediaByRecordId(recordId: Int!): RecordMedia
  " (live)"
  user(id: Int!): User
  " (live)"
  userPoint(id: Int!): UserPoint
  " (live)"
  userPointsHistory(id: Int!): UserPointsHistory
  " (live)"
  version(id: Int!): Version
  " (live)"
  vote(id: Int!): Vote
  " (live)"
  worldRecordGlobal(id: Int!): WorldRecordGlobal
  "Retrieves filtered level items based on specified criteria. (live)"
  zRtm(pMinAuthorTime: Float pMaxAuthorTime: Float pMinRecords: Int pMaxRecords: Int pExcludedAuthorIds: [Int] pExcludedHashes: [String] pMinCheckpoints: Int pMaxCheckpoints: Int pMinFinishes: Int pMaxFinishes: Int pMinBlocks: Int pMaxBlocks: Int pSampleSize: Int "Only read the first `n` values of the set." first: Int "Only read the last `n` values of the set." last: Int "Skip the first `n` values from our `after` cursor, an alternative to cursor\nbased pagination. May not be used with `last`." offset: Int "Read all values in the set before (above) this cursor." before: Cursor "Read all values in the set after (below) this cursor." after: Cursor "A filter to be used in determining which values should be returned by the collection." filter: ZRtmRecordFilter): ZRtmConnection
  "Reads a single `Favourite` using its globally unique `ID`. (live)"
  favouriteByNodeId("The globally unique `ID` to be used in selecting a single `Favourite`." nodeId: ID!): Favourite
  "Reads a single `Level` using its globally unique `ID`. (live)"
  levelByNodeId("The globally unique `ID` to be used in selecting a single `Level`." nodeId: ID!): Level
  "Reads a single `LevelItem` using its globally unique `ID`. (live)"
  levelItemByNodeId("The globally unique `ID` to be used in selecting a single `LevelItem`." nodeId: ID!): LevelItem
  "Reads a single `LevelMetadatum` using its globally unique `ID`. (live)"
  levelMetadatumByNodeId("The globally unique `ID` to be used in selecting a single `LevelMetadatum`." nodeId: ID!): LevelMetadatum
  "Reads a single `LevelPoint` using its globally unique `ID`. (live)"
  levelPointByNodeId("The globally unique `ID` to be used in selecting a single `LevelPoint`." nodeId: ID!): LevelPoint
  "Reads a single `LevelPointsHistory` using its globally unique `ID`. (live)"
  levelPointsHistoryByNodeId("The globally unique `ID` to be used in selecting a single `LevelPointsHistory`." nodeId: ID!): LevelPointsHistory
  "Reads a single `LevelRequest` using its globally unique `ID`. (live)"
  levelRequestByNodeId("The globally unique `ID` to be used in selecting a single `LevelRequest`." nodeId: ID!): LevelRequest
  "Reads a single `PersonalBestGlobal` using its globally unique `ID`. (live)"
  personalBestGlobalByNodeId("The globally unique `ID` to be used in selecting a single `PersonalBestGlobal`." nodeId: ID!): PersonalBestGlobal
  "Reads a single `Record` using its globally unique `ID`. (live)"
  recordByNodeId("The globally unique `ID` to be used in selecting a single `Record`." nodeId: ID!): Record
  "Reads a single `RecordMedia` using its globally unique `ID`. (live)"
  recordMediaByNodeId("The globally unique `ID` to be used in selecting a single `RecordMedia`." nodeId: ID!): RecordMedia
  "Reads a single `User` using its globally unique `ID`. (live)"
  userByNodeId("The globally unique `ID` to be used in selecting a single `User`." nodeId: ID!): User
  "Reads a single `UserPoint` using its globally unique `ID`. (live)"
  userPointByNodeId("The globally unique `ID` to be used in selecting a single `UserPoint`." nodeId: ID!): UserPoint
  "Reads a single `UserPointsHistory` using its globally unique `ID`. (live)"
  userPointsHistoryByNodeId("The globally unique `ID` to be used in selecting a single `UserPointsHistory`." nodeId: ID!): UserPointsHistory
  "Reads a single `Version` using its globally unique `ID`. (live)"
  versionByNodeId("The globally unique `ID` to be used in selecting a single `Version`." nodeId: ID!): Version
  "Reads a single `Vote` using its globally unique `ID`. (live)"
  voteByNodeId("The globally unique `ID` to be used in selecting a single `Vote`." nodeId: ID!): Vote
  "Reads a single `WorldRecordGlobal` using its globally unique `ID`. (live)"
  worldRecordGlobalByNodeId("The globally unique `ID` to be used in selecting a single `WorldRecordGlobal`." nodeId: ID!): WorldRecordGlobal
}